// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: burrow/payload.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Any encodes a sum type for which only one should be set
struct Payload_Any {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var callTx: Payload_CallTx {
    get {return _callTx ?? Payload_CallTx()}
    set {_callTx = newValue}
  }
  /// Returns true if `callTx` has been explicitly set.
  var hasCallTx: Bool {return self._callTx != nil}
  /// Clears the value of `callTx`. Subsequent reads from it will return its default value.
  mutating func clearCallTx() {self._callTx = nil}

  var sendTx: Payload_SendTx {
    get {return _sendTx ?? Payload_SendTx()}
    set {_sendTx = newValue}
  }
  /// Returns true if `sendTx` has been explicitly set.
  var hasSendTx: Bool {return self._sendTx != nil}
  /// Clears the value of `sendTx`. Subsequent reads from it will return its default value.
  mutating func clearSendTx() {self._sendTx = nil}

  var nameTx: Payload_NameTx {
    get {return _nameTx ?? Payload_NameTx()}
    set {_nameTx = newValue}
  }
  /// Returns true if `nameTx` has been explicitly set.
  var hasNameTx: Bool {return self._nameTx != nil}
  /// Clears the value of `nameTx`. Subsequent reads from it will return its default value.
  mutating func clearNameTx() {self._nameTx = nil}

  var permsTx: Payload_PermsTx {
    get {return _permsTx ?? Payload_PermsTx()}
    set {_permsTx = newValue}
  }
  /// Returns true if `permsTx` has been explicitly set.
  var hasPermsTx: Bool {return self._permsTx != nil}
  /// Clears the value of `permsTx`. Subsequent reads from it will return its default value.
  mutating func clearPermsTx() {self._permsTx = nil}

  var govTx: Payload_GovTx {
    get {return _govTx ?? Payload_GovTx()}
    set {_govTx = newValue}
  }
  /// Returns true if `govTx` has been explicitly set.
  var hasGovTx: Bool {return self._govTx != nil}
  /// Clears the value of `govTx`. Subsequent reads from it will return its default value.
  mutating func clearGovTx() {self._govTx = nil}

  var bondTx: Payload_BondTx {
    get {return _bondTx ?? Payload_BondTx()}
    set {_bondTx = newValue}
  }
  /// Returns true if `bondTx` has been explicitly set.
  var hasBondTx: Bool {return self._bondTx != nil}
  /// Clears the value of `bondTx`. Subsequent reads from it will return its default value.
  mutating func clearBondTx() {self._bondTx = nil}

  var unbondTx: Payload_UnbondTx {
    get {return _unbondTx ?? Payload_UnbondTx()}
    set {_unbondTx = newValue}
  }
  /// Returns true if `unbondTx` has been explicitly set.
  var hasUnbondTx: Bool {return self._unbondTx != nil}
  /// Clears the value of `unbondTx`. Subsequent reads from it will return its default value.
  mutating func clearUnbondTx() {self._unbondTx = nil}

  var batchTx: Payload_BatchTx {
    get {return _batchTx ?? Payload_BatchTx()}
    set {_batchTx = newValue}
  }
  /// Returns true if `batchTx` has been explicitly set.
  var hasBatchTx: Bool {return self._batchTx != nil}
  /// Clears the value of `batchTx`. Subsequent reads from it will return its default value.
  mutating func clearBatchTx() {self._batchTx = nil}

  var proposalTx: Payload_ProposalTx {
    get {return _proposalTx ?? Payload_ProposalTx()}
    set {_proposalTx = newValue}
  }
  /// Returns true if `proposalTx` has been explicitly set.
  var hasProposalTx: Bool {return self._proposalTx != nil}
  /// Clears the value of `proposalTx`. Subsequent reads from it will return its default value.
  mutating func clearProposalTx() {self._proposalTx = nil}

  var identifyTx: Payload_IdentifyTx {
    get {return _identifyTx ?? Payload_IdentifyTx()}
    set {_identifyTx = newValue}
  }
  /// Returns true if `identifyTx` has been explicitly set.
  var hasIdentifyTx: Bool {return self._identifyTx != nil}
  /// Clears the value of `identifyTx`. Subsequent reads from it will return its default value.
  mutating func clearIdentifyTx() {self._identifyTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _callTx: Payload_CallTx? = nil
  fileprivate var _sendTx: Payload_SendTx? = nil
  fileprivate var _nameTx: Payload_NameTx? = nil
  fileprivate var _permsTx: Payload_PermsTx? = nil
  fileprivate var _govTx: Payload_GovTx? = nil
  fileprivate var _bondTx: Payload_BondTx? = nil
  fileprivate var _unbondTx: Payload_UnbondTx? = nil
  fileprivate var _batchTx: Payload_BatchTx? = nil
  fileprivate var _proposalTx: Payload_ProposalTx? = nil
  fileprivate var _identifyTx: Payload_IdentifyTx? = nil
}

/// An input to a transaction that may carry an Amount as a charge and whose sequence number must be one greater than
/// that associated with the account at Address at the time of being received
struct Payload_TxInput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address from which this input flows
  var address: Data = SwiftProtobuf.Internal.emptyData

  /// The amount of native token to transfer from the input address
  var amount: UInt64 = 0

  /// The sequence number that this transaction will induce (i.e. one greater than the input account's current sequence)
  var sequence: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An output from a transaction that may carry an amount as a charge
struct Payload_TxOutput {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The address to which this output flows
  var address: Data = SwiftProtobuf.Internal.emptyData

  /// The amount of native token to transfer to the output address
  var amount: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A instruction to run smart contract code in the EVM
struct Payload_CallTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The caller's input
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// The contract address to call or nil if we are creating a contract
  var address: Data = SwiftProtobuf.Internal.emptyData

  /// The upper bound on the amount of gas (and therefore EVM execution steps) this CallTx may generate
  var gasLimit: UInt64 = 0

  /// Fee to offer validators for processing transaction
  var fee: UInt64 = 0

  /// EVM bytecode
  var data: Data = SwiftProtobuf.Internal.emptyData

  /// WASM bytecode
  var wasm: Data = SwiftProtobuf.Internal.emptyData

  /// Set of contracts this code will deploy
  var contractMeta: [Payload_ContractMeta] = []

  /// The upper bound on the price per unit of gas
  var gasPrice: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
}

struct Payload_ContractMeta {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var codeHash: Data = SwiftProtobuf.Internal.emptyData

  var meta: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// A payment between two sets of parties
struct Payload_SendTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The payers
  var inputs: [Payload_TxInput] = []

  /// The payees
  var outputs: [Payload_TxOutput] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// An update to the on-chain permissions
struct Payload_PermsTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The permission moderator
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// The modified permissions
  var permArgs: Permission_PermArgs {
    get {return _permArgs ?? Permission_PermArgs()}
    set {_permArgs = newValue}
  }
  /// Returns true if `permArgs` has been explicitly set.
  var hasPermArgs: Bool {return self._permArgs != nil}
  /// Clears the value of `permArgs`. Subsequent reads from it will return its default value.
  mutating func clearPermArgs() {self._permArgs = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
  fileprivate var _permArgs: Permission_PermArgs? = nil
}

/// A request to claim a globally unique name across the entire chain with some optional data storage leased for a fee
struct Payload_NameTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name updater
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// The name to update or create
  var name: String = String()

  /// The data to store against the name
  var data: String = String()

  /// The fee to provide that will determine the length of the name lease
  var fee: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
}

struct Payload_BondTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Input must be the validator that desires to bond
  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
}

struct Payload_UnbondTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  /// Account to unbond
  var output: Payload_TxOutput {
    get {return _output ?? Payload_TxOutput()}
    set {_output = newValue}
  }
  /// Returns true if `output` has been explicitly set.
  var hasOutput: Bool {return self._output != nil}
  /// Clears the value of `output`. Subsequent reads from it will return its default value.
  mutating func clearOutput() {self._output = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
  fileprivate var _output: Payload_TxOutput? = nil
}

struct Payload_GovTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [Payload_TxInput] = []

  var accountUpdates: [Spec_TemplateAccount] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Payload_ProposalTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var input: Payload_TxInput {
    get {return _input ?? Payload_TxInput()}
    set {_input = newValue}
  }
  /// Returns true if `input` has been explicitly set.
  var hasInput: Bool {return self._input != nil}
  /// Clears the value of `input`. Subsequent reads from it will return its default value.
  mutating func clearInput() {self._input = nil}

  var votingWeight: Int64 = 0

  var proposalHash: Data = SwiftProtobuf.Internal.emptyData

  var proposal: Payload_Proposal {
    get {return _proposal ?? Payload_Proposal()}
    set {_proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  var hasProposal: Bool {return self._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  mutating func clearProposal() {self._proposal = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _input: Payload_TxInput? = nil
  fileprivate var _proposal: Payload_Proposal? = nil
}

struct Payload_IdentifyTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Senders
  var inputs: [Payload_TxInput] = []

  /// Node to register
  var node: Registry_NodeIdentity {
    get {return _node ?? Registry_NodeIdentity()}
    set {_node = newValue}
  }
  /// Returns true if `node` has been explicitly set.
  var hasNode: Bool {return self._node != nil}
  /// Clears the value of `node`. Subsequent reads from it will return its default value.
  mutating func clearNode() {self._node = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _node: Registry_NodeIdentity? = nil
}

struct Payload_BatchTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [Payload_TxInput] = []

  var txs: [Payload_Any] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Payload_Vote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var address: Data = SwiftProtobuf.Internal.emptyData

  var votingWeight: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Payload_Proposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var description_p: String = String()

  var batchTx: Payload_BatchTx {
    get {return _batchTx ?? Payload_BatchTx()}
    set {_batchTx = newValue}
  }
  /// Returns true if `batchTx` has been explicitly set.
  var hasBatchTx: Bool {return self._batchTx != nil}
  /// Clears the value of `batchTx`. Subsequent reads from it will return its default value.
  mutating func clearBatchTx() {self._batchTx = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _batchTx: Payload_BatchTx? = nil
}

struct Payload_Ballot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proposal: Payload_Proposal {
    get {return _proposal ?? Payload_Proposal()}
    set {_proposal = newValue}
  }
  /// Returns true if `proposal` has been explicitly set.
  var hasProposal: Bool {return self._proposal != nil}
  /// Clears the value of `proposal`. Subsequent reads from it will return its default value.
  mutating func clearProposal() {self._proposal = nil}

  var finalizingTx: Data = SwiftProtobuf.Internal.emptyData

  var proposalState: Payload_Ballot.ProposalState = .proposed

  var votes: [Payload_Vote] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum ProposalState: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// PROPOSED might be expired, if sequence number of any of the input accounts are out of date
    case proposed // = 0
    case executed // = 1
    case failed // = 2
    case UNRECOGNIZED(Int)

    init() {
      self = .proposed
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .proposed
      case 1: self = .executed
      case 2: self = .failed
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .proposed: return 0
      case .executed: return 1
      case .failed: return 2
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}

  fileprivate var _proposal: Payload_Proposal? = nil
}

#if swift(>=4.2)

extension Payload_Ballot.ProposalState: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Payload_Ballot.ProposalState] = [
    .proposed,
    .executed,
    .failed,
  ]
}

#endif  // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "payload"

extension Payload_Any: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Any"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CallTx"),
    2: .same(proto: "SendTx"),
    3: .same(proto: "NameTx"),
    4: .same(proto: "PermsTx"),
    5: .same(proto: "GovTx"),
    6: .same(proto: "BondTx"),
    7: .same(proto: "UnbondTx"),
    8: .same(proto: "BatchTx"),
    9: .same(proto: "ProposalTx"),
    10: .same(proto: "IdentifyTx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._callTx)
      case 2: try decoder.decodeSingularMessageField(value: &self._sendTx)
      case 3: try decoder.decodeSingularMessageField(value: &self._nameTx)
      case 4: try decoder.decodeSingularMessageField(value: &self._permsTx)
      case 5: try decoder.decodeSingularMessageField(value: &self._govTx)
      case 6: try decoder.decodeSingularMessageField(value: &self._bondTx)
      case 7: try decoder.decodeSingularMessageField(value: &self._unbondTx)
      case 8: try decoder.decodeSingularMessageField(value: &self._batchTx)
      case 9: try decoder.decodeSingularMessageField(value: &self._proposalTx)
      case 10: try decoder.decodeSingularMessageField(value: &self._identifyTx)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._callTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._sendTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._nameTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._permsTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    if let v = self._govTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }
    if let v = self._bondTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    if let v = self._unbondTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }
    if let v = self._batchTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }
    if let v = self._proposalTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if let v = self._identifyTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Any, rhs: Payload_Any) -> Bool {
    if lhs._callTx != rhs._callTx {return false}
    if lhs._sendTx != rhs._sendTx {return false}
    if lhs._nameTx != rhs._nameTx {return false}
    if lhs._permsTx != rhs._permsTx {return false}
    if lhs._govTx != rhs._govTx {return false}
    if lhs._bondTx != rhs._bondTx {return false}
    if lhs._unbondTx != rhs._unbondTx {return false}
    if lhs._batchTx != rhs._batchTx {return false}
    if lhs._proposalTx != rhs._proposalTx {return false}
    if lhs._identifyTx != rhs._identifyTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_TxInput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxInput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "Amount"),
    3: .same(proto: "Sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.amount)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.sequence)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    if self.sequence != 0 {
      try visitor.visitSingularUInt64Field(value: self.sequence, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_TxInput, rhs: Payload_TxInput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_TxOutput: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TxOutput"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "Amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularUInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_TxOutput, rhs: Payload_TxOutput) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_CallTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CallTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "Address"),
    3: .same(proto: "GasLimit"),
    4: .same(proto: "Fee"),
    5: .same(proto: "Data"),
    6: .same(proto: "WASM"),
    7: .same(proto: "ContractMeta"),
    8: .same(proto: "GasPrice"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      case 2: try decoder.decodeSingularBytesField(value: &self.address)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.gasLimit)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.fee)
      case 5: try decoder.decodeSingularBytesField(value: &self.data)
      case 6: try decoder.decodeSingularBytesField(value: &self.wasm)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.contractMeta)
      case 8: try decoder.decodeSingularUInt64Field(value: &self.gasPrice)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 2)
    }
    if self.gasLimit != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasLimit, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    if !self.wasm.isEmpty {
      try visitor.visitSingularBytesField(value: self.wasm, fieldNumber: 6)
    }
    if !self.contractMeta.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.contractMeta, fieldNumber: 7)
    }
    if self.gasPrice != 0 {
      try visitor.visitSingularUInt64Field(value: self.gasPrice, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_CallTx, rhs: Payload_CallTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.address != rhs.address {return false}
    if lhs.gasLimit != rhs.gasLimit {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.data != rhs.data {return false}
    if lhs.wasm != rhs.wasm {return false}
    if lhs.contractMeta != rhs.contractMeta {return false}
    if lhs.gasPrice != rhs.gasPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_ContractMeta: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ContractMeta"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "CodeHash"),
    2: .same(proto: "Meta"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.codeHash)
      case 2: try decoder.decodeSingularStringField(value: &self.meta)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.codeHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.codeHash, fieldNumber: 1)
    }
    if !self.meta.isEmpty {
      try visitor.visitSingularStringField(value: self.meta, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_ContractMeta, rhs: Payload_ContractMeta) -> Bool {
    if lhs.codeHash != rhs.codeHash {return false}
    if lhs.meta != rhs.meta {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_SendTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".SendTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "Outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.inputs)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_SendTx, rhs: Payload_SendTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_PermsTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PermsTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "PermArgs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      case 2: try decoder.decodeSingularMessageField(value: &self._permArgs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._permArgs {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_PermsTx, rhs: Payload_PermsTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._permArgs != rhs._permArgs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_NameTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NameTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "Name"),
    3: .same(proto: "Data"),
    4: .same(proto: "Fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.data)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.fee)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularStringField(value: self.data, fieldNumber: 3)
    }
    if self.fee != 0 {
      try visitor.visitSingularUInt64Field(value: self.fee, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_NameTx, rhs: Payload_NameTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.name != rhs.name {return false}
    if lhs.data != rhs.data {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_BondTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BondTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_BondTx, rhs: Payload_BondTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_UnbondTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnbondTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "Output"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      case 2: try decoder.decodeSingularMessageField(value: &self._output)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._output {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_UnbondTx, rhs: Payload_UnbondTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs._output != rhs._output {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_GovTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GovTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "AccountUpdates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.inputs)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.accountUpdates)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.accountUpdates.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.accountUpdates, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_GovTx, rhs: Payload_GovTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.accountUpdates != rhs.accountUpdates {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_ProposalTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProposalTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Input"),
    2: .same(proto: "VotingWeight"),
    3: .same(proto: "ProposalHash"),
    4: .same(proto: "Proposal"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._input)
      case 2: try decoder.decodeSingularInt64Field(value: &self.votingWeight)
      case 3: try decoder.decodeSingularBytesField(value: &self.proposalHash)
      case 4: try decoder.decodeSingularMessageField(value: &self._proposal)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._input {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.votingWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.votingWeight, fieldNumber: 2)
    }
    if !self.proposalHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposalHash, fieldNumber: 3)
    }
    if let v = self._proposal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_ProposalTx, rhs: Payload_ProposalTx) -> Bool {
    if lhs._input != rhs._input {return false}
    if lhs.votingWeight != rhs.votingWeight {return false}
    if lhs.proposalHash != rhs.proposalHash {return false}
    if lhs._proposal != rhs._proposal {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_IdentifyTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IdentifyTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "Node"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.inputs)
      case 2: try decoder.decodeSingularMessageField(value: &self._node)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if let v = self._node {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_IdentifyTx, rhs: Payload_IdentifyTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs._node != rhs._node {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_BatchTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Inputs"),
    2: .same(proto: "Txs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.inputs)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.txs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.txs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.txs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_BatchTx, rhs: Payload_BatchTx) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.txs != rhs.txs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Vote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Address"),
    2: .same(proto: "VotingWeight"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeSingularInt64Field(value: &self.votingWeight)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if self.votingWeight != 0 {
      try visitor.visitSingularInt64Field(value: self.votingWeight, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Vote, rhs: Payload_Vote) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.votingWeight != rhs.votingWeight {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Proposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Proposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Name"),
    2: .same(proto: "Description"),
    3: .same(proto: "BatchTx"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularMessageField(value: &self._batchTx)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if let v = self._batchTx {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Proposal, rhs: Payload_Proposal) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs._batchTx != rhs._batchTx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Ballot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Ballot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "Proposal"),
    2: .same(proto: "FinalizingTx"),
    4: .same(proto: "proposalState"),
    5: .same(proto: "Votes"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._proposal)
      case 2: try decoder.decodeSingularBytesField(value: &self.finalizingTx)
      case 4: try decoder.decodeSingularEnumField(value: &self.proposalState)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.votes)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._proposal {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.finalizingTx.isEmpty {
      try visitor.visitSingularBytesField(value: self.finalizingTx, fieldNumber: 2)
    }
    if self.proposalState != .proposed {
      try visitor.visitSingularEnumField(value: self.proposalState, fieldNumber: 4)
    }
    if !self.votes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.votes, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Payload_Ballot, rhs: Payload_Ballot) -> Bool {
    if lhs._proposal != rhs._proposal {return false}
    if lhs.finalizingTx != rhs.finalizingTx {return false}
    if lhs.proposalState != rhs.proposalState {return false}
    if lhs.votes != rhs.votes {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Payload_Ballot.ProposalState: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "PROPOSED"),
    1: .same(proto: "EXECUTED"),
    2: .same(proto: "FAILED"),
  ]
}
