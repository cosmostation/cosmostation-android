// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: confio/proofs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Ics23_HashOp: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// NO_HASH is the default if no data passed. Note this is an illegal argument some places.
  case noHash // = 0
  case sha256 // = 1
  case sha512 // = 2
  case keccak // = 3
  case ripemd160 // = 4

  /// ripemd160(sha256(x))
  case bitcoin // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .noHash
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noHash
    case 1: self = .sha256
    case 2: self = .sha512
    case 3: self = .keccak
    case 4: self = .ripemd160
    case 5: self = .bitcoin
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noHash: return 0
    case .sha256: return 1
    case .sha512: return 2
    case .keccak: return 3
    case .ripemd160: return 4
    case .bitcoin: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ics23_HashOp: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ics23_HashOp] = [
    .noHash,
    .sha256,
    .sha512,
    .keccak,
    .ripemd160,
    .bitcoin,
  ]
}

#endif  // swift(>=4.2)

///*
///LengthOp defines how to process the key and value of the LeafOp
///to include length information. After encoding the length with the given
///algorithm, the length will be prepended to the key and value bytes.
///(Each one with it's own encoded length)
enum Ics23_LengthOp: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// NO_PREFIX don't include any length info
  case noPrefix // = 0

  /// VAR_PROTO uses protobuf (and go-amino) varint encoding of the length
  case varProto // = 1

  /// VAR_RLP uses rlp int encoding of the length
  case varRlp // = 2

  /// FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer
  case fixed32Big // = 3

  /// FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer
  case fixed32Little // = 4

  /// FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer
  case fixed64Big // = 5

  /// FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer
  case fixed64Little // = 6

  /// REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output)
  case require32Bytes // = 7

  /// REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output)
  case require64Bytes // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .noPrefix
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .noPrefix
    case 1: self = .varProto
    case 2: self = .varRlp
    case 3: self = .fixed32Big
    case 4: self = .fixed32Little
    case 5: self = .fixed64Big
    case 6: self = .fixed64Little
    case 7: self = .require32Bytes
    case 8: self = .require64Bytes
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .noPrefix: return 0
    case .varProto: return 1
    case .varRlp: return 2
    case .fixed32Big: return 3
    case .fixed32Little: return 4
    case .fixed64Big: return 5
    case .fixed64Little: return 6
    case .require32Bytes: return 7
    case .require64Bytes: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Ics23_LengthOp: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Ics23_LengthOp] = [
    .noPrefix,
    .varProto,
    .varRlp,
    .fixed32Big,
    .fixed32Little,
    .fixed64Big,
    .fixed64Little,
    .require32Bytes,
    .require64Bytes,
  ]
}

#endif  // swift(>=4.2)

///*
///ExistenceProof takes a key and a value and a set of steps to perform on it.
///The result of peforming all these steps will provide a "root hash", which can
///be compared to the value in a header.
///
///Since it is computationally infeasible to produce a hash collission for any of the used
///cryptographic hash functions, if someone can provide a series of operations to transform
///a given key and value into a root hash that matches some trusted root, these key and values
///must be in the referenced merkle tree.
///
///The only possible issue is maliablity in LeafOp, such as providing extra prefix data,
///which should be controlled by a spec. Eg. with lengthOp as NONE,
///prefix = FOO, key = BAR, value = CHOICE
///and
///prefix = F, key = OOBAR, value = CHOICE
///would produce the same value.
///
///With LengthOp this is tricker but not impossible. Which is why the "leafPrefixEqual" field
///in the ProofSpec is valuable to prevent this mutability. And why all trees should
///length-prefix the data before hashing it.
struct Ics23_ExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Data = SwiftProtobuf.Internal.emptyData

  var value: Data = SwiftProtobuf.Internal.emptyData

  var leaf: Ics23_LeafOp {
    get {return _leaf ?? Ics23_LeafOp()}
    set {_leaf = newValue}
  }
  /// Returns true if `leaf` has been explicitly set.
  var hasLeaf: Bool {return self._leaf != nil}
  /// Clears the value of `leaf`. Subsequent reads from it will return its default value.
  mutating func clearLeaf() {self._leaf = nil}

  var path: [Ics23_InnerOp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leaf: Ics23_LeafOp? = nil
}

///
///NonExistenceProof takes a proof of two neighbors, one left of the desired key,
///one right of the desired key. If both proofs are valid AND they are neighbors,
///then there is no valid proof for the given key.
struct Ics23_NonExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: remove this as unnecessary??? we prove a range
  var key: Data = SwiftProtobuf.Internal.emptyData

  var left: Ics23_ExistenceProof {
    get {return _left ?? Ics23_ExistenceProof()}
    set {_left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return self._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {self._left = nil}

  var right: Ics23_ExistenceProof {
    get {return _right ?? Ics23_ExistenceProof()}
    set {_right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return self._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {self._right = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _left: Ics23_ExistenceProof? = nil
  fileprivate var _right: Ics23_ExistenceProof? = nil
}

///
///CommitmentProof is either an ExistenceProof or a NonExistenceProof, or a Batch of such messages
struct Ics23_CommitmentProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Ics23_CommitmentProof.OneOf_Proof? = nil

  var exist: Ics23_ExistenceProof {
    get {
      if case .exist(let v)? = proof {return v}
      return Ics23_ExistenceProof()
    }
    set {proof = .exist(newValue)}
  }

  var nonexist: Ics23_NonExistenceProof {
    get {
      if case .nonexist(let v)? = proof {return v}
      return Ics23_NonExistenceProof()
    }
    set {proof = .nonexist(newValue)}
  }

  var batch: Ics23_BatchProof {
    get {
      if case .batch(let v)? = proof {return v}
      return Ics23_BatchProof()
    }
    set {proof = .batch(newValue)}
  }

  var compressed: Ics23_CompressedBatchProof {
    get {
      if case .compressed(let v)? = proof {return v}
      return Ics23_CompressedBatchProof()
    }
    set {proof = .compressed(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Proof: Equatable {
    case exist(Ics23_ExistenceProof)
    case nonexist(Ics23_NonExistenceProof)
    case batch(Ics23_BatchProof)
    case compressed(Ics23_CompressedBatchProof)

  #if !swift(>=4.1)
    static func ==(lhs: Ics23_CommitmentProof.OneOf_Proof, rhs: Ics23_CommitmentProof.OneOf_Proof) -> Bool {
      switch (lhs, rhs) {
      case (.exist(let l), .exist(let r)): return l == r
      case (.nonexist(let l), .nonexist(let r)): return l == r
      case (.batch(let l), .batch(let r)): return l == r
      case (.compressed(let l), .compressed(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///*
///LeafOp represents the raw key-value data we wish to prove, and
///must be flexible to represent the internal transformation from
///the original key-value pairs into the basis hash, for many existing
///merkle trees.
///
///key and value are passed in. So that the signature of this operation is:
///leafOp(key, value) -> output
///
///To process this, first prehash the keys and values if needed (ANY means no hash in this case):
///hkey = prehashKey(key)
///hvalue = prehashValue(value)
///
///Then combine the bytes, and hash it
///output = hash(prefix || length(hkey) || hkey || length(hvalue) || hvalue)
struct Ics23_LeafOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Ics23_HashOp = .noHash

  var prehashKey: Ics23_HashOp = .noHash

  var prehashValue: Ics23_HashOp = .noHash

  var length: Ics23_LengthOp = .noPrefix

  /// prefix is a fixed bytes that may optionally be included at the beginning to differentiate
  /// a leaf node from an inner node.
  var prefix: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///InnerOp represents a merkle-proof step that is not a leaf.
///It represents concatenating two children and hashing them to provide the next result.
///
///The result of the previous step is passed in, so the signature of this op is:
///innerOp(child) -> output
///
///The result of applying InnerOp should be:
///output = op.hash(op.prefix || child || op.suffix)
///
///where the || operator is concatenation of binary data,
///and child is the result of hashing all the tree below this step.
///
///Any special data, like prepending child with the length, or prepending the entire operation with
///some value to differentiate from leaf nodes, should be included in prefix and suffix.
///If either of prefix or suffix is empty, we just treat it as an empty string
struct Ics23_InnerOp {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var hash: Ics23_HashOp = .noHash

  var prefix: Data = SwiftProtobuf.Internal.emptyData

  var suffix: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
///ProofSpec defines what the expected parameters are for a given proof type.
///This can be stored in the client and used to validate any incoming proofs.
///
///verify(ProofSpec, Proof) -> Proof | Error
///
///As demonstrated in tests, if we don't fix the algorithm used to calculate the
///LeafHash for a given tree, there are many possible key-value pairs that can
///generate a given hash (by interpretting the preimage differently).
///We need this for proper security, requires client knows a priori what
///tree format server uses. But not in code, rather a configuration object.
struct Ics23_ProofSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// any field in the ExistenceProof must be the same as in this spec.
  /// except Prefix, which is just the first bytes of prefix (spec can be longer) 
  var leafSpec: Ics23_LeafOp {
    get {return _leafSpec ?? Ics23_LeafOp()}
    set {_leafSpec = newValue}
  }
  /// Returns true if `leafSpec` has been explicitly set.
  var hasLeafSpec: Bool {return self._leafSpec != nil}
  /// Clears the value of `leafSpec`. Subsequent reads from it will return its default value.
  mutating func clearLeafSpec() {self._leafSpec = nil}

  var innerSpec: Ics23_InnerSpec {
    get {return _innerSpec ?? Ics23_InnerSpec()}
    set {_innerSpec = newValue}
  }
  /// Returns true if `innerSpec` has been explicitly set.
  var hasInnerSpec: Bool {return self._innerSpec != nil}
  /// Clears the value of `innerSpec`. Subsequent reads from it will return its default value.
  mutating func clearInnerSpec() {self._innerSpec = nil}

  /// max_depth (if > 0) is the maximum number of InnerOps allowed (mainly for fixed-depth tries)
  var maxDepth: Int32 = 0

  /// min_depth (if > 0) is the minimum number of InnerOps allowed (mainly for fixed-depth tries)
  var minDepth: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leafSpec: Ics23_LeafOp? = nil
  fileprivate var _innerSpec: Ics23_InnerSpec? = nil
}

///
///InnerSpec contains all store-specific structure info to determine if two proofs from a
///given store are neighbors.
///
///This enables:
///
///isLeftMost(spec: InnerSpec, op: InnerOp)
///isRightMost(spec: InnerSpec, op: InnerOp)
///isLeftNeighbor(spec: InnerSpec, left: InnerOp, right: InnerOp)
struct Ics23_InnerSpec {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Child order is the ordering of the children node, must count from 0
  /// iavl tree is [0, 1] (left then right)
  /// merk is [0, 2, 1] (left, right, here)
  var childOrder: [Int32] = []

  var childSize: Int32 = 0

  var minPrefixLength: Int32 = 0

  var maxPrefixLength: Int32 = 0

  /// empty child is the prehash image that is used when one child is nil (eg. 20 bytes of 0)
  var emptyChild: Data = SwiftProtobuf.Internal.emptyData

  /// hash is the algorithm that must be used for each InnerOp
  var hash: Ics23_HashOp = .noHash

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///
///BatchProof is a group of multiple proof types than can be compressed
struct Ics23_BatchProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Ics23_BatchEntry] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Use BatchEntry not CommitmentProof, to avoid recursion
struct Ics23_BatchEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Ics23_BatchEntry.OneOf_Proof? = nil

  var exist: Ics23_ExistenceProof {
    get {
      if case .exist(let v)? = proof {return v}
      return Ics23_ExistenceProof()
    }
    set {proof = .exist(newValue)}
  }

  var nonexist: Ics23_NonExistenceProof {
    get {
      if case .nonexist(let v)? = proof {return v}
      return Ics23_NonExistenceProof()
    }
    set {proof = .nonexist(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Proof: Equatable {
    case exist(Ics23_ExistenceProof)
    case nonexist(Ics23_NonExistenceProof)

  #if !swift(>=4.1)
    static func ==(lhs: Ics23_BatchEntry.OneOf_Proof, rhs: Ics23_BatchEntry.OneOf_Proof) -> Bool {
      switch (lhs, rhs) {
      case (.exist(let l), .exist(let r)): return l == r
      case (.nonexist(let l), .nonexist(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ics23_CompressedBatchProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var entries: [Ics23_CompressedBatchEntry] = []

  var lookupInners: [Ics23_InnerOp] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Use BatchEntry not CommitmentProof, to avoid recursion
struct Ics23_CompressedBatchEntry {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var proof: Ics23_CompressedBatchEntry.OneOf_Proof? = nil

  var exist: Ics23_CompressedExistenceProof {
    get {
      if case .exist(let v)? = proof {return v}
      return Ics23_CompressedExistenceProof()
    }
    set {proof = .exist(newValue)}
  }

  var nonexist: Ics23_CompressedNonExistenceProof {
    get {
      if case .nonexist(let v)? = proof {return v}
      return Ics23_CompressedNonExistenceProof()
    }
    set {proof = .nonexist(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Proof: Equatable {
    case exist(Ics23_CompressedExistenceProof)
    case nonexist(Ics23_CompressedNonExistenceProof)

  #if !swift(>=4.1)
    static func ==(lhs: Ics23_CompressedBatchEntry.OneOf_Proof, rhs: Ics23_CompressedBatchEntry.OneOf_Proof) -> Bool {
      switch (lhs, rhs) {
      case (.exist(let l), .exist(let r)): return l == r
      case (.nonexist(let l), .nonexist(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

struct Ics23_CompressedExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: Data = SwiftProtobuf.Internal.emptyData

  var value: Data = SwiftProtobuf.Internal.emptyData

  var leaf: Ics23_LeafOp {
    get {return _leaf ?? Ics23_LeafOp()}
    set {_leaf = newValue}
  }
  /// Returns true if `leaf` has been explicitly set.
  var hasLeaf: Bool {return self._leaf != nil}
  /// Clears the value of `leaf`. Subsequent reads from it will return its default value.
  mutating func clearLeaf() {self._leaf = nil}

  /// these are indexes into the lookup_inners table in CompressedBatchProof
  var path: [Int32] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _leaf: Ics23_LeafOp? = nil
}

struct Ics23_CompressedNonExistenceProof {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// TODO: remove this as unnecessary??? we prove a range
  var key: Data = SwiftProtobuf.Internal.emptyData

  var left: Ics23_CompressedExistenceProof {
    get {return _left ?? Ics23_CompressedExistenceProof()}
    set {_left = newValue}
  }
  /// Returns true if `left` has been explicitly set.
  var hasLeft: Bool {return self._left != nil}
  /// Clears the value of `left`. Subsequent reads from it will return its default value.
  mutating func clearLeft() {self._left = nil}

  var right: Ics23_CompressedExistenceProof {
    get {return _right ?? Ics23_CompressedExistenceProof()}
    set {_right = newValue}
  }
  /// Returns true if `right` has been explicitly set.
  var hasRight: Bool {return self._right != nil}
  /// Clears the value of `right`. Subsequent reads from it will return its default value.
  mutating func clearRight() {self._right = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _left: Ics23_CompressedExistenceProof? = nil
  fileprivate var _right: Ics23_CompressedExistenceProof? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "ics23"

extension Ics23_HashOp: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_HASH"),
    1: .same(proto: "SHA256"),
    2: .same(proto: "SHA512"),
    3: .same(proto: "KECCAK"),
    4: .same(proto: "RIPEMD160"),
    5: .same(proto: "BITCOIN"),
  ]
}

extension Ics23_LengthOp: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "NO_PREFIX"),
    1: .same(proto: "VAR_PROTO"),
    2: .same(proto: "VAR_RLP"),
    3: .same(proto: "FIXED32_BIG"),
    4: .same(proto: "FIXED32_LITTLE"),
    5: .same(proto: "FIXED64_BIG"),
    6: .same(proto: "FIXED64_LITTLE"),
    7: .same(proto: "REQUIRE_32_BYTES"),
    8: .same(proto: "REQUIRE_64_BYTES"),
  ]
}

extension Ics23_ExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "leaf"),
    4: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.key)
      case 2: try decoder.decodeSingularBytesField(value: &self.value)
      case 3: try decoder.decodeSingularMessageField(value: &self._leaf)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if let v = self._leaf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_ExistenceProof, rhs: Ics23_ExistenceProof) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._leaf != rhs._leaf {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_NonExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NonExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "left"),
    3: .same(proto: "right"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.key)
      case 2: try decoder.decodeSingularMessageField(value: &self._left)
      case 3: try decoder.decodeSingularMessageField(value: &self._right)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if let v = self._left {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._right {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_NonExistenceProof, rhs: Ics23_NonExistenceProof) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._left != rhs._left {return false}
    if lhs._right != rhs._right {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_CommitmentProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CommitmentProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exist"),
    2: .same(proto: "nonexist"),
    3: .same(proto: "batch"),
    4: .same(proto: "compressed"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Ics23_ExistenceProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .exist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .exist(v)}
      case 2:
        var v: Ics23_NonExistenceProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .nonexist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .nonexist(v)}
      case 3:
        var v: Ics23_BatchProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .batch(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .batch(v)}
      case 4:
        var v: Ics23_CompressedBatchProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .compressed(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .compressed(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.proof {
    case .exist(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .nonexist(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case .batch(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    case .compressed(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_CommitmentProof, rhs: Ics23_CommitmentProof) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_LeafOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LeafOp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .standard(proto: "prehash_key"),
    3: .standard(proto: "prehash_value"),
    4: .same(proto: "length"),
    5: .same(proto: "prefix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.hash)
      case 2: try decoder.decodeSingularEnumField(value: &self.prehashKey)
      case 3: try decoder.decodeSingularEnumField(value: &self.prehashValue)
      case 4: try decoder.decodeSingularEnumField(value: &self.length)
      case 5: try decoder.decodeSingularBytesField(value: &self.prefix)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hash != .noHash {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 1)
    }
    if self.prehashKey != .noHash {
      try visitor.visitSingularEnumField(value: self.prehashKey, fieldNumber: 2)
    }
    if self.prehashValue != .noHash {
      try visitor.visitSingularEnumField(value: self.prehashValue, fieldNumber: 3)
    }
    if self.length != .noPrefix {
      try visitor.visitSingularEnumField(value: self.length, fieldNumber: 4)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_LeafOp, rhs: Ics23_LeafOp) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.prehashKey != rhs.prehashKey {return false}
    if lhs.prehashValue != rhs.prehashValue {return false}
    if lhs.length != rhs.length {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_InnerOp: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InnerOp"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "hash"),
    2: .same(proto: "prefix"),
    3: .same(proto: "suffix"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularEnumField(value: &self.hash)
      case 2: try decoder.decodeSingularBytesField(value: &self.prefix)
      case 3: try decoder.decodeSingularBytesField(value: &self.suffix)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.hash != .noHash {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 1)
    }
    if !self.prefix.isEmpty {
      try visitor.visitSingularBytesField(value: self.prefix, fieldNumber: 2)
    }
    if !self.suffix.isEmpty {
      try visitor.visitSingularBytesField(value: self.suffix, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_InnerOp, rhs: Ics23_InnerOp) -> Bool {
    if lhs.hash != rhs.hash {return false}
    if lhs.prefix != rhs.prefix {return false}
    if lhs.suffix != rhs.suffix {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_ProofSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ProofSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "leaf_spec"),
    2: .standard(proto: "inner_spec"),
    3: .standard(proto: "max_depth"),
    4: .standard(proto: "min_depth"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._leafSpec)
      case 2: try decoder.decodeSingularMessageField(value: &self._innerSpec)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maxDepth)
      case 4: try decoder.decodeSingularInt32Field(value: &self.minDepth)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._leafSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._innerSpec {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if self.maxDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.maxDepth, fieldNumber: 3)
    }
    if self.minDepth != 0 {
      try visitor.visitSingularInt32Field(value: self.minDepth, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_ProofSpec, rhs: Ics23_ProofSpec) -> Bool {
    if lhs._leafSpec != rhs._leafSpec {return false}
    if lhs._innerSpec != rhs._innerSpec {return false}
    if lhs.maxDepth != rhs.maxDepth {return false}
    if lhs.minDepth != rhs.minDepth {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_InnerSpec: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".InnerSpec"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "child_order"),
    2: .standard(proto: "child_size"),
    3: .standard(proto: "min_prefix_length"),
    4: .standard(proto: "max_prefix_length"),
    5: .standard(proto: "empty_child"),
    6: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedInt32Field(value: &self.childOrder)
      case 2: try decoder.decodeSingularInt32Field(value: &self.childSize)
      case 3: try decoder.decodeSingularInt32Field(value: &self.minPrefixLength)
      case 4: try decoder.decodeSingularInt32Field(value: &self.maxPrefixLength)
      case 5: try decoder.decodeSingularBytesField(value: &self.emptyChild)
      case 6: try decoder.decodeSingularEnumField(value: &self.hash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.childOrder.isEmpty {
      try visitor.visitPackedInt32Field(value: self.childOrder, fieldNumber: 1)
    }
    if self.childSize != 0 {
      try visitor.visitSingularInt32Field(value: self.childSize, fieldNumber: 2)
    }
    if self.minPrefixLength != 0 {
      try visitor.visitSingularInt32Field(value: self.minPrefixLength, fieldNumber: 3)
    }
    if self.maxPrefixLength != 0 {
      try visitor.visitSingularInt32Field(value: self.maxPrefixLength, fieldNumber: 4)
    }
    if !self.emptyChild.isEmpty {
      try visitor.visitSingularBytesField(value: self.emptyChild, fieldNumber: 5)
    }
    if self.hash != .noHash {
      try visitor.visitSingularEnumField(value: self.hash, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_InnerSpec, rhs: Ics23_InnerSpec) -> Bool {
    if lhs.childOrder != rhs.childOrder {return false}
    if lhs.childSize != rhs.childSize {return false}
    if lhs.minPrefixLength != rhs.minPrefixLength {return false}
    if lhs.maxPrefixLength != rhs.maxPrefixLength {return false}
    if lhs.emptyChild != rhs.emptyChild {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_BatchProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entries)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_BatchProof, rhs: Ics23_BatchProof) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_BatchEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".BatchEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exist"),
    2: .same(proto: "nonexist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Ics23_ExistenceProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .exist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .exist(v)}
      case 2:
        var v: Ics23_NonExistenceProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .nonexist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .nonexist(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.proof {
    case .exist(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .nonexist(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_BatchEntry, rhs: Ics23_BatchEntry) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_CompressedBatchProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedBatchProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "entries"),
    2: .standard(proto: "lookup_inners"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.entries)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.lookupInners)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.entries.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.entries, fieldNumber: 1)
    }
    if !self.lookupInners.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.lookupInners, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_CompressedBatchProof, rhs: Ics23_CompressedBatchProof) -> Bool {
    if lhs.entries != rhs.entries {return false}
    if lhs.lookupInners != rhs.lookupInners {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_CompressedBatchEntry: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedBatchEntry"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exist"),
    2: .same(proto: "nonexist"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        var v: Ics23_CompressedExistenceProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .exist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .exist(v)}
      case 2:
        var v: Ics23_CompressedNonExistenceProof?
        if let current = self.proof {
          try decoder.handleConflictingOneOf()
          if case .nonexist(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {self.proof = .nonexist(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.proof {
    case .exist(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    case .nonexist(let v)?:
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_CompressedBatchEntry, rhs: Ics23_CompressedBatchEntry) -> Bool {
    if lhs.proof != rhs.proof {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_CompressedExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "value"),
    3: .same(proto: "leaf"),
    4: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.key)
      case 2: try decoder.decodeSingularBytesField(value: &self.value)
      case 3: try decoder.decodeSingularMessageField(value: &self._leaf)
      case 4: try decoder.decodeRepeatedInt32Field(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if !self.value.isEmpty {
      try visitor.visitSingularBytesField(value: self.value, fieldNumber: 2)
    }
    if let v = self._leaf {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if !self.path.isEmpty {
      try visitor.visitPackedInt32Field(value: self.path, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_CompressedExistenceProof, rhs: Ics23_CompressedExistenceProof) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.value != rhs.value {return false}
    if lhs._leaf != rhs._leaf {return false}
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Ics23_CompressedNonExistenceProof: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CompressedNonExistenceProof"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .same(proto: "left"),
    3: .same(proto: "right"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.key)
      case 2: try decoder.decodeSingularMessageField(value: &self._left)
      case 3: try decoder.decodeSingularMessageField(value: &self._right)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularBytesField(value: self.key, fieldNumber: 1)
    }
    if let v = self._left {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if let v = self._right {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Ics23_CompressedNonExistenceProof, rhs: Ics23_CompressedNonExistenceProof) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs._left != rhs._left {return false}
    if lhs._right != rhs._right {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
