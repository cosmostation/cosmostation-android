// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: oracle/v1/oracle.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// ResolveStatus encodes the status of an oracle request.
enum Oracle_V1_ResolveStatus: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// Open - the request is not yet resolved.
  case openUnspecified // = 0

  /// Success - the request has been resolved successfully with no errors.
  case success // = 1

  /// Failure - an error occured during the request's resolve call.
  case failure // = 2

  /// Expired - the request does not get enough reports from validator within the
  /// timeframe.
  case expired // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .openUnspecified
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .openUnspecified
    case 1: self = .success
    case 2: self = .failure
    case 3: self = .expired
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .openUnspecified: return 0
    case .success: return 1
    case .failure: return 2
    case .expired: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Oracle_V1_ResolveStatus: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Oracle_V1_ResolveStatus] = [
    .openUnspecified,
    .success,
    .failure,
    .expired,
  ]
}

#endif  // swift(>=4.2)

/// DataSource is the data structure for storing data sources in the storage.
struct Oracle_V1_DataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Owner is an address of the account who own the data source
  var owner: String = String()

  /// Name is data source name used for display
  var name: String = String()

  /// Description is data source description used for display
  var description_p: String = String()

  /// Filename is string of file name used as reference for locating
  /// data source file stored in bandchain nodes
  var filename: String = String()

  /// Treasury is the account address who receive data source fee from requester.
  var treasury: String = String()

  /// Fee is the data source fee per ask_count that data provider will receive
  /// from requester.
  var fee: [Cosmos_Base_V1beta1_Coin] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OracleScript is the data structure for storing oracle scripts in the storage.
struct Oracle_V1_OracleScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Owner is an address of the account who own the oracle script
  var owner: String = String()

  /// Name is oracle script name used for display
  var name: String = String()

  /// Description is oracle script description used for display
  var description_p: String = String()

  /// Filename is string of file name used as reference for locating
  /// compiled oracle script WASM file stored in bandchain nodes
  var filename: String = String()

  /// Schema is the schema of the oracle script input/output
  /// which is formatted in OBI format e.g.
  /// "{symbol:string,multiplier:u64}/{px:u64}"
  var schema: String = String()

  /// SourceCodeURL is the URL of oracle script's source code.
  /// It is recommendded to store source code on IPFS and get its URL to preserve
  /// decentralization.
  var sourceCodeURL: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RawRequest is the data structure for storing raw requests in the storage.
struct Oracle_V1_RawRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ExternalID is an ID of the raw request
  var externalID: Int64 = 0

  /// DataSourceID is an ID of data source script that relates to the raw request
  var dataSourceID: Int64 = 0

  /// Calldata is the data used as argument params for executing data source
  /// script
  var calldata: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RawRequest is the data structure for storing raw reporter in the storage.
struct Oracle_V1_RawReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ExternalID is an ID of the raw request
  var externalID: Int64 = 0

  /// ExitCode is status code provided by validators to specify error, if any.
  /// Exit code is usually filled by the exit code returned from execution of
  /// specified data source script. With code 0 means there is no error.
  var exitCode: UInt32 = 0

  /// Data is raw result provided by validators.
  /// It is usually filled by the result from execution of specified data source
  /// script.
  var data: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Request is the data structure for storing requests in the storage.
struct Oracle_V1_Request {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OracleScriptID is ID of an oracle script
  var oracleScriptID: Int64 = 0

  /// Calldata is the data used as argument params for the oracle script
  var calldata: Data = Data()

  /// RequestedValidators is a list of validator addresses that are assigned for
  /// fulfilling the request
  var requestedValidators: [String] = []

  /// MinCount is minimum number of validators required for fulfilling the
  /// request
  var minCount: UInt64 = 0

  /// RequestHeight is block height that the request has been created
  var requestHeight: Int64 = 0

  /// RequestTime is timestamp of the chain's block which contains the request
  var requestTime: UInt64 = 0

  /// ClientID is arbitrary id provided by requester.
  /// It is used by client-side for referencing the request
  var clientID: String = String()

  /// RawRequests is a list of raw requests specified by execution of oracle
  /// script
  var rawRequests: [Oracle_V1_RawRequest] = []

  /// IBCChannel is an IBC channel info of the other chain, which contains a
  /// channel and a port to allow bandchain connect to that chain. This field
  /// allows other chain be able to request data from bandchain via IBC.
  var ibcChannel: Oracle_V1_IBCChannel {
    get {return _ibcChannel ?? Oracle_V1_IBCChannel()}
    set {_ibcChannel = newValue}
  }
  /// Returns true if `ibcChannel` has been explicitly set.
  var hasIbcChannel: Bool {return self._ibcChannel != nil}
  /// Clears the value of `ibcChannel`. Subsequent reads from it will return its default value.
  mutating func clearIbcChannel() {self._ibcChannel = nil}

  /// ExecuteGas is amount of gas to reserve for executing
  var executeGas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ibcChannel: Oracle_V1_IBCChannel? = nil
}

/// Report is the data structure for storing reports in the storage.
struct Oracle_V1_Report {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Validator is a validator address who submit the report
  var validator: String = String()

  /// InBeforeResolve indicates whether the report is submitted before the
  /// request resolved
  var inBeforeResolve: Bool = false

  /// RawReports is list of raw reports provided by the validator.
  /// Each raw report has different external ID
  var rawReports: [Oracle_V1_RawReport] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OracleRequestPacketData encodes an oracle request sent from other blockchains
/// to BandChain.
struct Oracle_V1_OracleRequestPacketData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID is the unique identifier of this oracle request, as specified by
  /// the client. This same unique ID will be sent back to the requester with the
  /// oracle response.
  var clientID: String = String()

  /// OracleScriptID is the unique identifier of the oracle script to be
  /// executed.
  var oracleScriptID: Int64 = 0

  /// Calldata is the OBI-encoded calldata bytes available for oracle executor to
  /// read.
  var calldata: Data = Data()

  /// AskCount is the number of validators that are requested to respond to this
  /// oracle request. Higher value means more security, at a higher gas cost.
  var askCount: UInt64 = 0

  /// MinCount is the minimum number of validators necessary for the request to
  /// proceed to the execution phase. Higher value means more security, at the
  /// cost of liveness.
  var minCount: UInt64 = 0

  /// FeeLimit is the maximum tokens that will be paid to all data source
  /// providers.
  var feeLimit: [Cosmos_Base_V1beta1_Coin] = []

  /// RequestKey is the key from request chain to match data source fee payer on
  /// Bandchain
  var requestKey: String = String()

  /// PrepareGas is amount of gas to pay to prepare raw requests
  var prepareGas: UInt64 = 0

  /// ExecuteGas is amount of gas to reserve for executing
  var executeGas: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OracleRequestPacketAcknowledgement encodes an oracle request acknowledgement
/// send back to requester chain.
struct Oracle_V1_OracleRequestPacketAcknowledgement {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestID is BandChain's unique identifier for this oracle request.
  var requestID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// OracleResponsePacketData encodes an oracle response from BandChain to the
/// requester.
struct Oracle_V1_OracleResponsePacketData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID is the unique identifier matched with that of the oracle request
  /// packet.
  var clientID: String = String()

  /// RequestID is BandChain's unique identifier for this oracle request.
  var requestID: Int64 = 0

  /// AnsCount is the number of validators among to the asked validators that
  /// actually responded to this oracle request prior to this oracle request
  /// being resolved.
  var ansCount: UInt64 = 0

  /// RequestTime is the UNIX epoch time at which the request was sent to
  /// BandChain.
  var requestTime: Int64 = 0

  /// ResolveTime is the UNIX epoch time at which the request was resolved to the
  /// final result.
  var resolveTime: Int64 = 0

  /// ResolveStatus is the status of this oracle request, which can be OK,
  /// FAILURE, or EXPIRED.
  var resolveStatus: Oracle_V1_ResolveStatus = .openUnspecified

  /// Result is the final aggregated value encoded in OBI format. Only available
  /// if status if OK.
  var result: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Result encodes a result of request and store in chain
struct Oracle_V1_Result {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ClientID is the unique identifier of this oracle request, as specified by
  /// the client. This same unique ID will be sent back to the requester with the
  /// oracle response.
  var clientID: String = String()

  /// OracleScriptID is the unique identifier of the oracle script to be
  /// executed.
  var oracleScriptID: Int64 = 0

  /// Calldata is the calldata bytes available for oracle executor to read.
  var calldata: Data = Data()

  /// AskCount is the number of validators that are requested to respond to this
  /// oracle request. Higher value means more security, at a higher gas cost.
  var askCount: UInt64 = 0

  /// MinCount is the minimum number of validators necessary for the request to
  /// proceed to the execution phase. Higher value means more security, at the
  /// cost of liveness.
  var minCount: UInt64 = 0

  /// RequestID is BandChain's unique identifier for this oracle request.
  var requestID: Int64 = 0

  /// AnsCount is the number of validators among to the asked validators that
  /// actually responded to this oracle request prior to this oracle request
  /// being resolved.
  var ansCount: UInt64 = 0

  /// RequestTime is the UNIX epoch time at which the request was sent to
  /// BandChain.
  var requestTime: Int64 = 0

  /// ResolveTime is the UNIX epoch time at which the request was resolved to the
  /// final result.
  var resolveTime: Int64 = 0

  /// ResolveStatus is the status of this oracle request, which can be OK,
  /// FAILURE, or EXPIRED.
  var resolveStatus: Oracle_V1_ResolveStatus = .openUnspecified

  /// Result is the final aggregated value only available if status if OK.
  var result: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ValidatorStatus maintains whether a validator is an active oracle provider.
struct Oracle_V1_ValidatorStatus {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// IsActive is a boolean indicating active status of validator.
  /// The validator will be deactivated when they are unable to send reports
  /// to fulfill oracle request before the request expired.
  var isActive: Bool = false

  /// Since is a block timestamp when validator has been activated/deactivated
  var since: SwiftProtobuf.Google_Protobuf_Timestamp {
    get {return _since ?? SwiftProtobuf.Google_Protobuf_Timestamp()}
    set {_since = newValue}
  }
  /// Returns true if `since` has been explicitly set.
  var hasSince: Bool {return self._since != nil}
  /// Clears the value of `since`. Subsequent reads from it will return its default value.
  mutating func clearSince() {self._since = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _since: SwiftProtobuf.Google_Protobuf_Timestamp? = nil
}

/// ActiveValidator is information of currently active validator
struct Oracle_V1_ActiveValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Address is a validator address
  var address: String = String()

  /// Power is an amount of token that the validator is holding
  var power: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// Params is the data structure that keeps the parameters of the oracle module.
struct Oracle_V1_Params {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// MaxRawRequestCount is the maximum number of data source raw requests a
  /// request can make.
  var maxRawRequestCount: UInt64 = 0

  /// MaxAskCount is the maximum number of validators a request can target.
  var maxAskCount: UInt64 = 0

  /// ExpirationBlockCount is the number of blocks a request stays valid before
  /// it gets expired due to insufficient reports.
  var expirationBlockCount: UInt64 = 0

  /// BaseOwasmGas is the base amount of Cosmos-SDK gas charged for owasm
  /// execution.
  var baseOwasmGas: UInt64 = 0

  /// PerValidatorRequestGas is the amount of Cosmos-SDK gas charged per
  /// requested validator.
  var perValidatorRequestGas: UInt64 = 0

  /// SamplingTryCount the number of validator sampling tries to pick the highest
  /// voting power subset of validators to perform an oracle task.
  var samplingTryCount: UInt64 = 0

  /// OracleRewardPercentage is the percentage of block rewards allocated to
  /// active oracle validators.
  var oracleRewardPercentage: UInt64 = 0

  /// InactivePenaltyDuration is the duration period where a validator cannot
  /// activate back after missing an oracle report.
  var inactivePenaltyDuration: UInt64 = 0

  /// IBCRequestEnabled is a flag indicating whether sending oracle request via
  /// IBC is allowed
  var ibcRequestEnabled: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PendingResolveList is a list of requests that are waiting to be resolved
struct Oracle_V1_PendingResolveList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestIDs is a list of request IDs that are waiting to be resolved
  var requestIds: [Int64] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// IBCChannel is information of IBC protocol to allow communicating with other
/// chain
struct Oracle_V1_IBCChannel {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// PortID is port ID used for sending response packet when request is
  /// resolved.
  var portID: String = String()

  /// ChannelID is channel ID used for sending response packet when request is
  /// resolved.
  var channelID: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ReportersPerValidator is list of reporters that is associated with a
/// validator
struct Oracle_V1_ReportersPerValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Validator a validator address
  var validator: String = String()

  /// Reporters is a list of reporter account addresses associated with the
  /// validator
  var reporters: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// RequestVerification is a message that is constructed and signed by a reporter
/// to be used as a part of verification of oracle request.
struct Oracle_V1_RequestVerification {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// ChainID is the ID of targeted chain
  var chainID: String = String()

  /// Validator is an validator address
  var validator: String = String()

  /// RequestID is the targeted request ID
  var requestID: Int64 = 0

  /// ExternalID is the oracle's external ID of data source
  var externalID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// PriceResult is a result from standard price reference
struct Oracle_V1_PriceResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Symbol is unit of data indicating what the data is. It is price currencies
  /// for this case.
  var symbol: String = String()

  /// Multiplier is a number used for left-shifting value to eliminate decimal
  /// digits
  var multiplier: UInt64 = 0

  /// Px is the actual data, which is rate number multiplied by the multiplier.
  var px: UInt64 = 0

  /// RequestID is oracle request ID that contains this price
  var requestID: Int64 = 0

  /// ResolveTime is epoch timestamp indicating the time when the request had
  /// been resolved
  var resolveTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "oracle.v1"

extension Oracle_V1_ResolveStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESOLVE_STATUS_OPEN_UNSPECIFIED"),
    1: .same(proto: "RESOLVE_STATUS_SUCCESS"),
    2: .same(proto: "RESOLVE_STATUS_FAILURE"),
    3: .same(proto: "RESOLVE_STATUS_EXPIRED"),
  ]
}

extension Oracle_V1_DataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DataSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "filename"),
    5: .same(proto: "treasury"),
    6: .same(proto: "fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.treasury) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.fee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 4)
    }
    if !self.treasury.isEmpty {
      try visitor.visitSingularStringField(value: self.treasury, fieldNumber: 5)
    }
    if !self.fee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fee, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_DataSource, rhs: Oracle_V1_DataSource) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.treasury != rhs.treasury {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_OracleScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "owner"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "filename"),
    5: .same(proto: "schema"),
    6: .standard(proto: "source_code_url"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.filename) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.sourceCodeURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.filename.isEmpty {
      try visitor.visitSingularStringField(value: self.filename, fieldNumber: 4)
    }
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 5)
    }
    if !self.sourceCodeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceCodeURL, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_OracleScript, rhs: Oracle_V1_OracleScript) -> Bool {
    if lhs.owner != rhs.owner {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.filename != rhs.filename {return false}
    if lhs.schema != rhs.schema {return false}
    if lhs.sourceCodeURL != rhs.sourceCodeURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_RawRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "external_id"),
    2: .standard(proto: "data_source_id"),
    3: .same(proto: "calldata"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.externalID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.dataSourceID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.calldata) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.externalID != 0 {
      try visitor.visitSingularInt64Field(value: self.externalID, fieldNumber: 1)
    }
    if self.dataSourceID != 0 {
      try visitor.visitSingularInt64Field(value: self.dataSourceID, fieldNumber: 2)
    }
    if !self.calldata.isEmpty {
      try visitor.visitSingularBytesField(value: self.calldata, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_RawRequest, rhs: Oracle_V1_RawRequest) -> Bool {
    if lhs.externalID != rhs.externalID {return false}
    if lhs.dataSourceID != rhs.dataSourceID {return false}
    if lhs.calldata != rhs.calldata {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_RawReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RawReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "external_id"),
    2: .standard(proto: "exit_code"),
    3: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.externalID) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.exitCode) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.data) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.externalID != 0 {
      try visitor.visitSingularInt64Field(value: self.externalID, fieldNumber: 1)
    }
    if self.exitCode != 0 {
      try visitor.visitSingularUInt32Field(value: self.exitCode, fieldNumber: 2)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_RawReport, rhs: Oracle_V1_RawReport) -> Bool {
    if lhs.externalID != rhs.externalID {return false}
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_script_id"),
    2: .same(proto: "calldata"),
    3: .standard(proto: "requested_validators"),
    4: .standard(proto: "min_count"),
    5: .standard(proto: "request_height"),
    6: .standard(proto: "request_time"),
    7: .standard(proto: "client_id"),
    8: .standard(proto: "raw_requests"),
    9: .standard(proto: "ibc_channel"),
    10: .standard(proto: "execute_gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.calldata) }()
      case 3: try { try decoder.decodeRepeatedStringField(value: &self.requestedValidators) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.requestHeight) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.requestTime) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.rawRequests) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._ibcChannel) }()
      case 10: try { try decoder.decodeSingularUInt64Field(value: &self.executeGas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 1)
    }
    if !self.calldata.isEmpty {
      try visitor.visitSingularBytesField(value: self.calldata, fieldNumber: 2)
    }
    if !self.requestedValidators.isEmpty {
      try visitor.visitRepeatedStringField(value: self.requestedValidators, fieldNumber: 3)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 4)
    }
    if self.requestHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.requestHeight, fieldNumber: 5)
    }
    if self.requestTime != 0 {
      try visitor.visitSingularUInt64Field(value: self.requestTime, fieldNumber: 6)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 7)
    }
    if !self.rawRequests.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawRequests, fieldNumber: 8)
    }
    if let v = self._ibcChannel {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }
    if self.executeGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.executeGas, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_Request, rhs: Oracle_V1_Request) -> Bool {
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.calldata != rhs.calldata {return false}
    if lhs.requestedValidators != rhs.requestedValidators {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.requestHeight != rhs.requestHeight {return false}
    if lhs.requestTime != rhs.requestTime {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.rawRequests != rhs.rawRequests {return false}
    if lhs._ibcChannel != rhs._ibcChannel {return false}
    if lhs.executeGas != rhs.executeGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_Report: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Report"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .standard(proto: "in_before_resolve"),
    3: .standard(proto: "raw_reports"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.inBeforeResolve) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.rawReports) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 1)
    }
    if self.inBeforeResolve != false {
      try visitor.visitSingularBoolField(value: self.inBeforeResolve, fieldNumber: 2)
    }
    if !self.rawReports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawReports, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_Report, rhs: Oracle_V1_Report) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.inBeforeResolve != rhs.inBeforeResolve {return false}
    if lhs.rawReports != rhs.rawReports {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_OracleRequestPacketData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleRequestPacketData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "oracle_script_id"),
    3: .same(proto: "calldata"),
    4: .standard(proto: "ask_count"),
    5: .standard(proto: "min_count"),
    6: .standard(proto: "fee_limit"),
    7: .standard(proto: "request_key"),
    8: .standard(proto: "prepare_gas"),
    9: .standard(proto: "execute_gas"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.calldata) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.askCount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.feeLimit) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.requestKey) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.prepareGas) }()
      case 9: try { try decoder.decodeSingularUInt64Field(value: &self.executeGas) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 2)
    }
    if !self.calldata.isEmpty {
      try visitor.visitSingularBytesField(value: self.calldata, fieldNumber: 3)
    }
    if self.askCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.askCount, fieldNumber: 4)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 5)
    }
    if !self.feeLimit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeLimit, fieldNumber: 6)
    }
    if !self.requestKey.isEmpty {
      try visitor.visitSingularStringField(value: self.requestKey, fieldNumber: 7)
    }
    if self.prepareGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.prepareGas, fieldNumber: 8)
    }
    if self.executeGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.executeGas, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_OracleRequestPacketData, rhs: Oracle_V1_OracleRequestPacketData) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.calldata != rhs.calldata {return false}
    if lhs.askCount != rhs.askCount {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.requestKey != rhs.requestKey {return false}
    if lhs.prepareGas != rhs.prepareGas {return false}
    if lhs.executeGas != rhs.executeGas {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_OracleRequestPacketAcknowledgement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleRequestPacketAcknowledgement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.requestID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_OracleRequestPacketAcknowledgement, rhs: Oracle_V1_OracleRequestPacketAcknowledgement) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_OracleResponsePacketData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".OracleResponsePacketData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "request_id"),
    3: .standard(proto: "ans_count"),
    4: .standard(proto: "request_time"),
    5: .standard(proto: "resolve_time"),
    6: .standard(proto: "resolve_status"),
    7: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.requestID) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.ansCount) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.requestTime) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.resolveTime) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.resolveStatus) }()
      case 7: try { try decoder.decodeSingularBytesField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.requestID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestID, fieldNumber: 2)
    }
    if self.ansCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.ansCount, fieldNumber: 3)
    }
    if self.requestTime != 0 {
      try visitor.visitSingularInt64Field(value: self.requestTime, fieldNumber: 4)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularInt64Field(value: self.resolveTime, fieldNumber: 5)
    }
    if self.resolveStatus != .openUnspecified {
      try visitor.visitSingularEnumField(value: self.resolveStatus, fieldNumber: 6)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularBytesField(value: self.result, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_OracleResponsePacketData, rhs: Oracle_V1_OracleResponsePacketData) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.ansCount != rhs.ansCount {return false}
    if lhs.requestTime != rhs.requestTime {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.resolveStatus != rhs.resolveStatus {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Result"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "client_id"),
    2: .standard(proto: "oracle_script_id"),
    3: .same(proto: "calldata"),
    4: .standard(proto: "ask_count"),
    5: .standard(proto: "min_count"),
    6: .standard(proto: "request_id"),
    7: .standard(proto: "ans_count"),
    8: .standard(proto: "request_time"),
    9: .standard(proto: "resolve_time"),
    10: .standard(proto: "resolve_status"),
    11: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 2: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.calldata) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.askCount) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      case 6: try { try decoder.decodeSingularInt64Field(value: &self.requestID) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.ansCount) }()
      case 8: try { try decoder.decodeSingularInt64Field(value: &self.requestTime) }()
      case 9: try { try decoder.decodeSingularInt64Field(value: &self.resolveTime) }()
      case 10: try { try decoder.decodeSingularEnumField(value: &self.resolveStatus) }()
      case 11: try { try decoder.decodeSingularBytesField(value: &self.result) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 1)
    }
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 2)
    }
    if !self.calldata.isEmpty {
      try visitor.visitSingularBytesField(value: self.calldata, fieldNumber: 3)
    }
    if self.askCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.askCount, fieldNumber: 4)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 5)
    }
    if self.requestID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestID, fieldNumber: 6)
    }
    if self.ansCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.ansCount, fieldNumber: 7)
    }
    if self.requestTime != 0 {
      try visitor.visitSingularInt64Field(value: self.requestTime, fieldNumber: 8)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularInt64Field(value: self.resolveTime, fieldNumber: 9)
    }
    if self.resolveStatus != .openUnspecified {
      try visitor.visitSingularEnumField(value: self.resolveStatus, fieldNumber: 10)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularBytesField(value: self.result, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_Result, rhs: Oracle_V1_Result) -> Bool {
    if lhs.clientID != rhs.clientID {return false}
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.calldata != rhs.calldata {return false}
    if lhs.askCount != rhs.askCount {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.ansCount != rhs.ansCount {return false}
    if lhs.requestTime != rhs.requestTime {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.resolveStatus != rhs.resolveStatus {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_ValidatorStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ValidatorStatus"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_active"),
    2: .same(proto: "since"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.isActive) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._since) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isActive != false {
      try visitor.visitSingularBoolField(value: self.isActive, fieldNumber: 1)
    }
    if let v = self._since {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_ValidatorStatus, rhs: Oracle_V1_ValidatorStatus) -> Bool {
    if lhs.isActive != rhs.isActive {return false}
    if lhs._since != rhs._since {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_ActiveValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ActiveValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "power"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.address) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.power) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.power != 0 {
      try visitor.visitSingularUInt64Field(value: self.power, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_ActiveValidator, rhs: Oracle_V1_ActiveValidator) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.power != rhs.power {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_Params: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Params"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "max_raw_request_count"),
    2: .standard(proto: "max_ask_count"),
    3: .standard(proto: "expiration_block_count"),
    4: .standard(proto: "base_owasm_gas"),
    5: .standard(proto: "per_validator_request_gas"),
    6: .standard(proto: "sampling_try_count"),
    7: .standard(proto: "oracle_reward_percentage"),
    8: .standard(proto: "inactive_penalty_duration"),
    9: .standard(proto: "ibc_request_enabled"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self.maxRawRequestCount) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.maxAskCount) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.expirationBlockCount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.baseOwasmGas) }()
      case 5: try { try decoder.decodeSingularUInt64Field(value: &self.perValidatorRequestGas) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.samplingTryCount) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.oracleRewardPercentage) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.inactivePenaltyDuration) }()
      case 9: try { try decoder.decodeSingularBoolField(value: &self.ibcRequestEnabled) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.maxRawRequestCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxRawRequestCount, fieldNumber: 1)
    }
    if self.maxAskCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.maxAskCount, fieldNumber: 2)
    }
    if self.expirationBlockCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.expirationBlockCount, fieldNumber: 3)
    }
    if self.baseOwasmGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.baseOwasmGas, fieldNumber: 4)
    }
    if self.perValidatorRequestGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.perValidatorRequestGas, fieldNumber: 5)
    }
    if self.samplingTryCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.samplingTryCount, fieldNumber: 6)
    }
    if self.oracleRewardPercentage != 0 {
      try visitor.visitSingularUInt64Field(value: self.oracleRewardPercentage, fieldNumber: 7)
    }
    if self.inactivePenaltyDuration != 0 {
      try visitor.visitSingularUInt64Field(value: self.inactivePenaltyDuration, fieldNumber: 8)
    }
    if self.ibcRequestEnabled != false {
      try visitor.visitSingularBoolField(value: self.ibcRequestEnabled, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_Params, rhs: Oracle_V1_Params) -> Bool {
    if lhs.maxRawRequestCount != rhs.maxRawRequestCount {return false}
    if lhs.maxAskCount != rhs.maxAskCount {return false}
    if lhs.expirationBlockCount != rhs.expirationBlockCount {return false}
    if lhs.baseOwasmGas != rhs.baseOwasmGas {return false}
    if lhs.perValidatorRequestGas != rhs.perValidatorRequestGas {return false}
    if lhs.samplingTryCount != rhs.samplingTryCount {return false}
    if lhs.oracleRewardPercentage != rhs.oracleRewardPercentage {return false}
    if lhs.inactivePenaltyDuration != rhs.inactivePenaltyDuration {return false}
    if lhs.ibcRequestEnabled != rhs.ibcRequestEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_PendingResolveList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PendingResolveList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_ids"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt64Field(value: &self.requestIds) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.requestIds.isEmpty {
      try visitor.visitPackedInt64Field(value: self.requestIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_PendingResolveList, rhs: Oracle_V1_PendingResolveList) -> Bool {
    if lhs.requestIds != rhs.requestIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_IBCChannel: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".IBCChannel"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "port_id"),
    2: .standard(proto: "channel_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.portID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.channelID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.portID.isEmpty {
      try visitor.visitSingularStringField(value: self.portID, fieldNumber: 1)
    }
    if !self.channelID.isEmpty {
      try visitor.visitSingularStringField(value: self.channelID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_IBCChannel, rhs: Oracle_V1_IBCChannel) -> Bool {
    if lhs.portID != rhs.portID {return false}
    if lhs.channelID != rhs.channelID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_ReportersPerValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportersPerValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .same(proto: "reporters"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.reporters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 1)
    }
    if !self.reporters.isEmpty {
      try visitor.visitRepeatedStringField(value: self.reporters, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_ReportersPerValidator, rhs: Oracle_V1_ReportersPerValidator) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.reporters != rhs.reporters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_RequestVerification: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RequestVerification"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "chain_id"),
    2: .same(proto: "validator"),
    3: .standard(proto: "request_id"),
    4: .standard(proto: "external_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.chainID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 3: try { try decoder.decodeSingularInt64Field(value: &self.requestID) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.externalID) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainID.isEmpty {
      try visitor.visitSingularStringField(value: self.chainID, fieldNumber: 1)
    }
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 2)
    }
    if self.requestID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestID, fieldNumber: 3)
    }
    if self.externalID != 0 {
      try visitor.visitSingularInt64Field(value: self.externalID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_RequestVerification, rhs: Oracle_V1_RequestVerification) -> Bool {
    if lhs.chainID != rhs.chainID {return false}
    if lhs.validator != rhs.validator {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.externalID != rhs.externalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_PriceResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PriceResult"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "symbol"),
    2: .same(proto: "multiplier"),
    3: .same(proto: "px"),
    4: .standard(proto: "request_id"),
    5: .standard(proto: "resolve_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.symbol) }()
      case 2: try { try decoder.decodeSingularUInt64Field(value: &self.multiplier) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.px) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.requestID) }()
      case 5: try { try decoder.decodeSingularInt64Field(value: &self.resolveTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 1)
    }
    if self.multiplier != 0 {
      try visitor.visitSingularUInt64Field(value: self.multiplier, fieldNumber: 2)
    }
    if self.px != 0 {
      try visitor.visitSingularUInt64Field(value: self.px, fieldNumber: 3)
    }
    if self.requestID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestID, fieldNumber: 4)
    }
    if self.resolveTime != 0 {
      try visitor.visitSingularInt64Field(value: self.resolveTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_PriceResult, rhs: Oracle_V1_PriceResult) -> Bool {
    if lhs.symbol != rhs.symbol {return false}
    if lhs.multiplier != rhs.multiplier {return false}
    if lhs.px != rhs.px {return false}
    if lhs.requestID != rhs.requestID {return false}
    if lhs.resolveTime != rhs.resolveTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
