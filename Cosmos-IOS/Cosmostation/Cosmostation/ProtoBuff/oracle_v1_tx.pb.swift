// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: oracle/v1/tx.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgRequestData is a message for sending a data oracle request.
struct Oracle_V1_MsgRequestData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OracleScriptID is the identifier of the oracle script to be called.
  var oracleScriptID: Int64 = 0

  /// Calldata is the OBI-encoded call parameters for the oracle script.
  var calldata: Data = Data()

  /// AskCount is the number of validators to perform the oracle task.
  var askCount: UInt64 = 0

  /// MinCount is the minimum number of validators sufficient to resolve the
  /// oracle tasks.
  var minCount: UInt64 = 0

  /// ClientID is the client-provided unique identifier to track the request.
  var clientID: String = String()

  /// FeeLimit is the maximum tokens that will be paid to all data source
  /// providers.
  var feeLimit: [Cosmos_Base_V1beta1_Coin] = []

  /// PrepareGas is amount of gas to pay to prepare raw requests
  var prepareGas: UInt64 = 0

  /// ExecuteGas is amount of gas to reserve for executing
  var executeGas: UInt64 = 0

  /// Sender is an account address of message sender.
  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRequestDataResponse is response data for MsgRequestData message
struct Oracle_V1_MsgRequestDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReportData is a message for reporting to a data request by a validator.
struct Oracle_V1_MsgReportData {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// RequestID is the identifier of the request to be reported to.
  var requestID: Int64 = 0

  /// RawReports is the list of report information provided by data sources
  /// identified by external ID
  var rawReports: [Oracle_V1_RawReport] = []

  /// Validator is the address of the validator that owns this report.
  var validator: String = String()

  /// Reporter is the message signer who submits this report transaction for the
  /// validator.
  var reporter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgReportDataResponse is response data for MsgReportData message
struct Oracle_V1_MsgReportDataResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateDataSource is a message for creating a new data source.
struct Oracle_V1_MsgCreateDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of this data source used for display (optional).
  var name: String = String()

  /// Description is the description of this data source used for display
  /// (optional).
  var description_p: String = String()

  /// Executable is the content of executable script or binary file to be run by
  /// validators upon execution.
  var executable: Data = Data()

  /// Fee is the data source fee per ask_count that data provider will receive
  /// from requester.
  var fee: [Cosmos_Base_V1beta1_Coin] = []

  /// Treasury is the account address who receive data source fee from requester.
  var treasury: String = String()

  /// Owner is the account address who is allowed to make further changes to the
  /// data source.
  var owner: String = String()

  /// Sender is the signer of this message.
  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateDataSourceResponse is response data for MsgCreateDataSource message
struct Oracle_V1_MsgCreateDataSourceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditDataSource is a message for editing an existing data source.
struct Oracle_V1_MsgEditDataSource {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// DataSourceID is the unique identifier of the data source to be edited.
  var dataSourceID: Int64 = 0

  /// Name is the name of this data source used for display (optional).
  var name: String = String()

  /// Description is the description of this data source used for display
  /// (optional).
  var description_p: String = String()

  /// Executable is the executable script or binary to be run by validators upon
  /// execution.
  var executable: Data = Data()

  /// Fee is the data source fee per ask_count that data provider will receive
  /// from requester.
  var fee: [Cosmos_Base_V1beta1_Coin] = []

  /// Treasury is the address who receive data source fee from requester.
  var treasury: String = String()

  /// Owner is the address who is allowed to make further changes to the data
  /// source.
  var owner: String = String()

  /// Sender is the signer of this message. Must be the current data source's
  /// owner.
  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditDataSourceResponse is response data for MsgEditDataSource message
struct Oracle_V1_MsgEditDataSourceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateOracleScript is a message for creating an oracle script.
struct Oracle_V1_MsgCreateOracleScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Name is the name of this oracle script used for display (optional).
  var name: String = String()

  /// Description is the description of this oracle script used for display
  /// (optional).
  var description_p: String = String()

  /// Schema is the OBI schema of this oracle script (optional).
  var schema: String = String()

  /// SourceCodeURL is the absolute URI to the script's source code (optional).
  var sourceCodeURL: String = String()

  /// Code is the oracle WebAssembly binary code. Can be raw of gzip compressed.
  var code: Data = Data()

  /// Owner is the address who is allowed to make further changes to the oracle
  /// script.
  var owner: String = String()

  /// Sender is the signer of this message.
  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgCreateOracleScriptResponse is response data for MsgCreateOracleScript
/// message
struct Oracle_V1_MsgCreateOracleScriptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditOracleScript is a message for editing an existing oracle script.
struct Oracle_V1_MsgEditOracleScript {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// OracleScriptID is the unique identifier of the oracle script to be edited.
  var oracleScriptID: Int64 = 0

  /// Name is the name of this oracle script used for display (optional).
  var name: String = String()

  /// Description is the description of this oracle script used for display
  /// (optional).
  var description_p: String = String()

  /// Schema is the OBI schema of this oracle script (optional).
  var schema: String = String()

  /// SourceCodeURL is the absolute URI to the script's source code (optional).
  var sourceCodeURL: String = String()

  /// Code is the oracle WebAssembly binary code. Can be raw of gzip compressed.
  var code: Data = Data()

  /// Owner is an account address who is allowed to make further changes to the
  /// oracle script.
  var owner: String = String()

  /// Sender is an account address who sign this message. Must be the current
  /// oracle script's owner.
  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditOracleScriptResponse is response data for MsgEditOracleScript message
struct Oracle_V1_MsgEditOracleScriptResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgEditOracleScript is a message for activating a validator to become an
/// oracle provider. However, the activation can be revoked once the validator
/// is unable to provide data to fulfill requests
struct Oracle_V1_MsgActivate {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Validator is the validator address who sign this message and request to be
  /// activated.
  var validator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgActivateResponse is response data for MsgActivate message
struct Oracle_V1_MsgActivateResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddReporter is a message for adding a new reporter for a validator.
struct Oracle_V1_MsgAddReporter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Validator is the validator address who requested to add a new reporter.
  /// Note that this is the signer.
  var validator: String = String()

  /// Reporter is the account address to be added as a reporter to the validator.
  var reporter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddReporterResponse is response data for MsgAddReporter message
struct Oracle_V1_MsgAddReporterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgAddReporter is a message for removing an existing reporter from a
/// validator.
struct Oracle_V1_MsgRemoveReporter {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Validator is the validator address who requested to remove an existing
  /// reporter. Note that this is the signer.
  var validator: String = String()

  /// Reporter is the account address to be removed from being the validator's
  /// reporter.
  var reporter: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRemoveReporterResponse is response data for MsgRemoveReporter message
struct Oracle_V1_MsgRemoveReporterResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "oracle.v1"

extension Oracle_V1_MsgRequestData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRequestData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_script_id"),
    2: .same(proto: "calldata"),
    3: .standard(proto: "ask_count"),
    4: .standard(proto: "min_count"),
    5: .standard(proto: "client_id"),
    6: .standard(proto: "fee_limit"),
    7: .standard(proto: "prepare_gas"),
    8: .standard(proto: "execute_gas"),
    9: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.calldata) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.askCount) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.minCount) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.clientID) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.feeLimit) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self.prepareGas) }()
      case 8: try { try decoder.decodeSingularUInt64Field(value: &self.executeGas) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 1)
    }
    if !self.calldata.isEmpty {
      try visitor.visitSingularBytesField(value: self.calldata, fieldNumber: 2)
    }
    if self.askCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.askCount, fieldNumber: 3)
    }
    if self.minCount != 0 {
      try visitor.visitSingularUInt64Field(value: self.minCount, fieldNumber: 4)
    }
    if !self.clientID.isEmpty {
      try visitor.visitSingularStringField(value: self.clientID, fieldNumber: 5)
    }
    if !self.feeLimit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.feeLimit, fieldNumber: 6)
    }
    if self.prepareGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.prepareGas, fieldNumber: 7)
    }
    if self.executeGas != 0 {
      try visitor.visitSingularUInt64Field(value: self.executeGas, fieldNumber: 8)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgRequestData, rhs: Oracle_V1_MsgRequestData) -> Bool {
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.calldata != rhs.calldata {return false}
    if lhs.askCount != rhs.askCount {return false}
    if lhs.minCount != rhs.minCount {return false}
    if lhs.clientID != rhs.clientID {return false}
    if lhs.feeLimit != rhs.feeLimit {return false}
    if lhs.prepareGas != rhs.prepareGas {return false}
    if lhs.executeGas != rhs.executeGas {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgRequestDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRequestDataResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgRequestDataResponse, rhs: Oracle_V1_MsgRequestDataResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgReportData: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReportData"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "request_id"),
    2: .standard(proto: "raw_reports"),
    3: .same(proto: "validator"),
    4: .same(proto: "reporter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.requestID) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.rawReports) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.reporter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.requestID != 0 {
      try visitor.visitSingularInt64Field(value: self.requestID, fieldNumber: 1)
    }
    if !self.rawReports.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.rawReports, fieldNumber: 2)
    }
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 3)
    }
    if !self.reporter.isEmpty {
      try visitor.visitSingularStringField(value: self.reporter, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgReportData, rhs: Oracle_V1_MsgReportData) -> Bool {
    if lhs.requestID != rhs.requestID {return false}
    if lhs.rawReports != rhs.rawReports {return false}
    if lhs.validator != rhs.validator {return false}
    if lhs.reporter != rhs.reporter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgReportDataResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgReportDataResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgReportDataResponse, rhs: Oracle_V1_MsgReportDataResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgCreateDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDataSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "executable"),
    4: .same(proto: "fee"),
    5: .same(proto: "treasury"),
    6: .same(proto: "owner"),
    7: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.executable) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.fee) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.treasury) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.executable.isEmpty {
      try visitor.visitSingularBytesField(value: self.executable, fieldNumber: 3)
    }
    if !self.fee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fee, fieldNumber: 4)
    }
    if !self.treasury.isEmpty {
      try visitor.visitSingularStringField(value: self.treasury, fieldNumber: 5)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 6)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgCreateDataSource, rhs: Oracle_V1_MsgCreateDataSource) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.executable != rhs.executable {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.treasury != rhs.treasury {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgCreateDataSourceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateDataSourceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgCreateDataSourceResponse, rhs: Oracle_V1_MsgCreateDataSourceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgEditDataSource: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditDataSource"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "data_source_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "executable"),
    5: .same(proto: "fee"),
    6: .same(proto: "treasury"),
    7: .same(proto: "owner"),
    8: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.dataSourceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.executable) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.fee) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.treasury) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.dataSourceID != 0 {
      try visitor.visitSingularInt64Field(value: self.dataSourceID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.executable.isEmpty {
      try visitor.visitSingularBytesField(value: self.executable, fieldNumber: 4)
    }
    if !self.fee.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.fee, fieldNumber: 5)
    }
    if !self.treasury.isEmpty {
      try visitor.visitSingularStringField(value: self.treasury, fieldNumber: 6)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 7)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgEditDataSource, rhs: Oracle_V1_MsgEditDataSource) -> Bool {
    if lhs.dataSourceID != rhs.dataSourceID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.executable != rhs.executable {return false}
    if lhs.fee != rhs.fee {return false}
    if lhs.treasury != rhs.treasury {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgEditDataSourceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditDataSourceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgEditDataSourceResponse, rhs: Oracle_V1_MsgEditDataSourceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgCreateOracleScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateOracleScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "description"),
    3: .same(proto: "schema"),
    4: .standard(proto: "source_code_url"),
    5: .same(proto: "code"),
    6: .same(proto: "owner"),
    7: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.sourceCodeURL) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.code) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 3)
    }
    if !self.sourceCodeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceCodeURL, fieldNumber: 4)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularBytesField(value: self.code, fieldNumber: 5)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 6)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgCreateOracleScript, rhs: Oracle_V1_MsgCreateOracleScript) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.schema != rhs.schema {return false}
    if lhs.sourceCodeURL != rhs.sourceCodeURL {return false}
    if lhs.code != rhs.code {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgCreateOracleScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCreateOracleScriptResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgCreateOracleScriptResponse, rhs: Oracle_V1_MsgCreateOracleScriptResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgEditOracleScript: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditOracleScript"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "oracle_script_id"),
    2: .same(proto: "name"),
    3: .same(proto: "description"),
    4: .same(proto: "schema"),
    5: .standard(proto: "source_code_url"),
    6: .same(proto: "code"),
    7: .same(proto: "owner"),
    8: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt64Field(value: &self.oracleScriptID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.schema) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.sourceCodeURL) }()
      case 6: try { try decoder.decodeSingularBytesField(value: &self.code) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.owner) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.sender) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.oracleScriptID != 0 {
      try visitor.visitSingularInt64Field(value: self.oracleScriptID, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.schema.isEmpty {
      try visitor.visitSingularStringField(value: self.schema, fieldNumber: 4)
    }
    if !self.sourceCodeURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sourceCodeURL, fieldNumber: 5)
    }
    if !self.code.isEmpty {
      try visitor.visitSingularBytesField(value: self.code, fieldNumber: 6)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularStringField(value: self.owner, fieldNumber: 7)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgEditOracleScript, rhs: Oracle_V1_MsgEditOracleScript) -> Bool {
    if lhs.oracleScriptID != rhs.oracleScriptID {return false}
    if lhs.name != rhs.name {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.schema != rhs.schema {return false}
    if lhs.sourceCodeURL != rhs.sourceCodeURL {return false}
    if lhs.code != rhs.code {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgEditOracleScriptResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgEditOracleScriptResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgEditOracleScriptResponse, rhs: Oracle_V1_MsgEditOracleScriptResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgActivate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgActivate"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgActivate, rhs: Oracle_V1_MsgActivate) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgActivateResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgActivateResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgActivateResponse, rhs: Oracle_V1_MsgActivateResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgAddReporter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddReporter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .same(proto: "reporter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reporter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 1)
    }
    if !self.reporter.isEmpty {
      try visitor.visitSingularStringField(value: self.reporter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgAddReporter, rhs: Oracle_V1_MsgAddReporter) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.reporter != rhs.reporter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgAddReporterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgAddReporterResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgAddReporterResponse, rhs: Oracle_V1_MsgAddReporterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgRemoveReporter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveReporter"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .same(proto: "reporter"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.validator) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reporter) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 1)
    }
    if !self.reporter.isEmpty {
      try visitor.visitSingularStringField(value: self.reporter, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgRemoveReporter, rhs: Oracle_V1_MsgRemoveReporter) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.reporter != rhs.reporter {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Oracle_V1_MsgRemoveReporterResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRemoveReporterResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Oracle_V1_MsgRemoveReporterResponse, rhs: Oracle_V1_MsgRemoveReporterResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
