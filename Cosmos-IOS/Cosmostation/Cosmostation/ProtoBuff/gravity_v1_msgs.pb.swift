// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: gravity/v1/msgs.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// MsgSetOrchestratorAddress
/// this message allows validators to delegate their voting responsibilities
/// to a given key. This key is then used as an optional authentication method
/// for sigining oracle claims
/// VALIDATOR
/// The validator field is a cosmosvaloper1... string (i.e. sdk.ValAddress)
/// that references a validator in the active set
/// ORCHESTRATOR
/// The orchestrator field is a cosmos1... string  (i.e. sdk.AccAddress) that
/// references the key that is being delegated to
/// ETH_ADDRESS
/// This is a hex encoded 0x Ethereum public key that will be used by this validator
/// on Ethereum
struct Gravity_V1_MsgSetOrchestratorAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var validator: String = String()

  var orchestrator: String = String()

  var ethAddress: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgSetOrchestratorAddressResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgValsetConfirm
/// this is the message sent by the validators when they wish to submit their
/// signatures over the validator set at a given block height. A validator must
/// first call MsgSetEthAddress to set their Ethereum address to be used for
/// signing. Then someone (anyone) must make a ValsetRequest, the request is
/// essentially a messaging mechanism to determine which block all validators
/// should submit signatures over. Finally validators sign the validator set,
/// powers, and Ethereum addresses of the entire validator set at the height of a
/// ValsetRequest and submit that signature with this message.
///
/// If a sufficient number of validators (66% of voting power) (A) have set
/// Ethereum addresses and (B) submit ValsetConfirm messages with their
/// signatures it is then possible for anyone to view these signatures in the
/// chain store and submit them to Ethereum to update the validator set
/// -------------
struct Gravity_V1_MsgValsetConfirm {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt64 = 0

  var orchestrator: String = String()

  var ethAddress: String = String()

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgValsetConfirmResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgSendToEth
/// This is the message that a user calls when they want to bridge an asset
/// it will later be removed when it is included in a batch and successfully
/// submitted tokens are removed from the users balance immediately
/// -------------
/// AMOUNT:
/// the coin to send across the bridge, note the restriction that this is a
/// single coin not a set of coins that is normal in other Cosmos messages
/// FEE:
/// the fee paid for the bridge, distinct from the fee paid to the chain to
/// actually send this message in the first place. So a successful send has
/// two layers of fees for the user
struct Gravity_V1_MsgSendToEth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var ethDest: String = String()

  var amount: Cosmos_Base_V1beta1_Coin {
    get {return _amount ?? Cosmos_Base_V1beta1_Coin()}
    set {_amount = newValue}
  }
  /// Returns true if `amount` has been explicitly set.
  var hasAmount: Bool {return self._amount != nil}
  /// Clears the value of `amount`. Subsequent reads from it will return its default value.
  mutating func clearAmount() {self._amount = nil}

  var bridgeFee: Cosmos_Base_V1beta1_Coin {
    get {return _bridgeFee ?? Cosmos_Base_V1beta1_Coin()}
    set {_bridgeFee = newValue}
  }
  /// Returns true if `bridgeFee` has been explicitly set.
  var hasBridgeFee: Bool {return self._bridgeFee != nil}
  /// Clears the value of `bridgeFee`. Subsequent reads from it will return its default value.
  mutating func clearBridgeFee() {self._bridgeFee = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _amount: Cosmos_Base_V1beta1_Coin? = nil
  fileprivate var _bridgeFee: Cosmos_Base_V1beta1_Coin? = nil
}

struct Gravity_V1_MsgSendToEthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgRequestBatch
/// this is a message anyone can send that requests a batch of transactions to
/// send across the bridge be created for whatever block height this message is
/// included in. This acts as a coordination point, the handler for this message
/// looks at the AddToOutgoingPool tx's in the store and generates a batch, also
/// available in the store tied to this message. The validators then grab this
/// batch, sign it, submit the signatures with a MsgConfirmBatch before a relayer
/// can finally submit the batch
/// -------------
struct Gravity_V1_MsgRequestBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sender: String = String()

  var denom: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgRequestBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgConfirmBatch
/// When validators observe a MsgRequestBatch they form a batch by ordering
/// transactions currently in the txqueue in order of highest to lowest fee,
/// cutting off when the batch either reaches a hardcoded maximum size (to be
/// decided, probably around 100) or when transactions stop being profitable
/// (TODO determine this without nondeterminism) This message includes the batch
/// as well as an Ethereum signature over this batch by the validator
/// -------------
struct Gravity_V1_MsgConfirmBatch {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var nonce: UInt64 = 0

  var tokenContract: String = String()

  var ethSigner: String = String()

  var orchestrator: String = String()

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgConfirmBatchResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// MsgConfirmLogicCall
/// When validators observe a MsgRequestBatch they form a batch by ordering
/// transactions currently in the txqueue in order of highest to lowest fee,
/// cutting off when the batch either reaches a hardcoded maximum size (to be
/// decided, probably around 100) or when transactions stop being profitable
/// (TODO determine this without nondeterminism) This message includes the batch
/// as well as an Ethereum signature over this batch by the validator
/// -------------
struct Gravity_V1_MsgConfirmLogicCall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var invalidationID: String = String()

  var invalidationNonce: UInt64 = 0

  var ethSigner: String = String()

  var orchestrator: String = String()

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgConfirmLogicCallResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// EthereumBridgeDepositClaim
/// When more than 66% of the active validator set has
/// claimed to have seen the deposit enter the ethereum blockchain coins are
/// issued to the Cosmos address in question
/// -------------
struct Gravity_V1_MsgDepositClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var blockHeight: UInt64 = 0

  var tokenContract: String = String()

  var amount: String = String()

  var ethereumSender: String = String()

  var cosmosReceiver: String = String()

  var orchestrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgDepositClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// WithdrawClaim claims that a batch of withdrawal
/// operations on the bridge contract was executed.
struct Gravity_V1_MsgWithdrawClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var blockHeight: UInt64 = 0

  var batchNonce: UInt64 = 0

  var tokenContract: String = String()

  var orchestrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgWithdrawClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// ERC20DeployedClaim allows the Cosmos module
/// to learn about an ERC20 that someone deployed
/// to represent a Cosmos asset
struct Gravity_V1_MsgERC20DeployedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var blockHeight: UInt64 = 0

  var cosmosDenom: String = String()

  var tokenContract: String = String()

  var name: String = String()

  var symbol: String = String()

  var decimals: UInt64 = 0

  var orchestrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgERC20DeployedClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This informs the Cosmos module that a logic
/// call has been executed
struct Gravity_V1_MsgLogicCallExecutedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var blockHeight: UInt64 = 0

  var invalidationID: Data = SwiftProtobuf.Internal.emptyData

  var invalidationNonce: UInt64 = 0

  var orchestrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgLogicCallExecutedClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This informs the Cosmos module that a validator
/// set has been updated.
struct Gravity_V1_MsgValsetUpdatedClaim {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var eventNonce: UInt64 = 0

  var valsetNonce: UInt64 = 0

  var blockHeight: UInt64 = 0

  var members: [Gravity_V1_BridgeValidator] = []

  var orchestrator: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgValsetUpdatedClaimResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This call allows the sender (and only the sender)
/// to cancel a given MsgSendToEth and recieve a refund
/// of the tokens
struct Gravity_V1_MsgCancelSendToEth {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var transactionID: UInt64 = 0

  var sender: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Gravity_V1_MsgCancelSendToEthResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// This call allows anyone to submit evidence that a
/// validator has signed a valset, batch, or logic call that never
/// existed. Subject contains the batch, valset, or logic call.
struct Gravity_V1_MsgSubmitBadSignatureEvidence {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var subject: Google_Protobuf2_Any {
    get {return _subject ?? Google_Protobuf2_Any()}
    set {_subject = newValue}
  }
  /// Returns true if `subject` has been explicitly set.
  var hasSubject: Bool {return self._subject != nil}
  /// Clears the value of `subject`. Subsequent reads from it will return its default value.
  mutating func clearSubject() {self._subject = nil}

  var signature: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _subject: Google_Protobuf2_Any? = nil
}

struct Gravity_V1_MsgSubmitBadSignatureEvidenceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "gravity.v1"

extension Gravity_V1_MsgSetOrchestratorAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetOrchestratorAddress"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "validator"),
    2: .same(proto: "orchestrator"),
    3: .standard(proto: "eth_address"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.validator)
      case 2: try decoder.decodeSingularStringField(value: &self.orchestrator)
      case 3: try decoder.decodeSingularStringField(value: &self.ethAddress)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.validator.isEmpty {
      try visitor.visitSingularStringField(value: self.validator, fieldNumber: 1)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 2)
    }
    if !self.ethAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ethAddress, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSetOrchestratorAddress, rhs: Gravity_V1_MsgSetOrchestratorAddress) -> Bool {
    if lhs.validator != rhs.validator {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.ethAddress != rhs.ethAddress {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSetOrchestratorAddressResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSetOrchestratorAddressResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSetOrchestratorAddressResponse, rhs: Gravity_V1_MsgSetOrchestratorAddressResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgValsetConfirm: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgValsetConfirm"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .same(proto: "orchestrator"),
    3: .standard(proto: "eth_address"),
    4: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.nonce)
      case 2: try decoder.decodeSingularStringField(value: &self.orchestrator)
      case 3: try decoder.decodeSingularStringField(value: &self.ethAddress)
      case 4: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 2)
    }
    if !self.ethAddress.isEmpty {
      try visitor.visitSingularStringField(value: self.ethAddress, fieldNumber: 3)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgValsetConfirm, rhs: Gravity_V1_MsgValsetConfirm) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.ethAddress != rhs.ethAddress {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgValsetConfirmResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgValsetConfirmResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgValsetConfirmResponse, rhs: Gravity_V1_MsgValsetConfirmResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSendToEth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSendToEth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .standard(proto: "eth_dest"),
    3: .same(proto: "amount"),
    4: .standard(proto: "bridge_fee"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sender)
      case 2: try decoder.decodeSingularStringField(value: &self.ethDest)
      case 3: try decoder.decodeSingularMessageField(value: &self._amount)
      case 4: try decoder.decodeSingularMessageField(value: &self._bridgeFee)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.ethDest.isEmpty {
      try visitor.visitSingularStringField(value: self.ethDest, fieldNumber: 2)
    }
    if let v = self._amount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }
    if let v = self._bridgeFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSendToEth, rhs: Gravity_V1_MsgSendToEth) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.ethDest != rhs.ethDest {return false}
    if lhs._amount != rhs._amount {return false}
    if lhs._bridgeFee != rhs._bridgeFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSendToEthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSendToEthResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSendToEthResponse, rhs: Gravity_V1_MsgSendToEthResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgRequestBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRequestBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "denom"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.sender)
      case 2: try decoder.decodeSingularStringField(value: &self.denom)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 1)
    }
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgRequestBatch, rhs: Gravity_V1_MsgRequestBatch) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.denom != rhs.denom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgRequestBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgRequestBatchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgRequestBatchResponse, rhs: Gravity_V1_MsgRequestBatchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgConfirmBatch: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConfirmBatch"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "nonce"),
    2: .standard(proto: "token_contract"),
    3: .standard(proto: "eth_signer"),
    4: .same(proto: "orchestrator"),
    5: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.nonce)
      case 2: try decoder.decodeSingularStringField(value: &self.tokenContract)
      case 3: try decoder.decodeSingularStringField(value: &self.ethSigner)
      case 4: try decoder.decodeSingularStringField(value: &self.orchestrator)
      case 5: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.nonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.nonce, fieldNumber: 1)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 2)
    }
    if !self.ethSigner.isEmpty {
      try visitor.visitSingularStringField(value: self.ethSigner, fieldNumber: 3)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 4)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgConfirmBatch, rhs: Gravity_V1_MsgConfirmBatch) -> Bool {
    if lhs.nonce != rhs.nonce {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.ethSigner != rhs.ethSigner {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgConfirmBatchResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConfirmBatchResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgConfirmBatchResponse, rhs: Gravity_V1_MsgConfirmBatchResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgConfirmLogicCall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConfirmLogicCall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "invalidation_id"),
    2: .standard(proto: "invalidation_nonce"),
    3: .standard(proto: "eth_signer"),
    4: .same(proto: "orchestrator"),
    5: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.invalidationID)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.invalidationNonce)
      case 3: try decoder.decodeSingularStringField(value: &self.ethSigner)
      case 4: try decoder.decodeSingularStringField(value: &self.orchestrator)
      case 5: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.invalidationID.isEmpty {
      try visitor.visitSingularStringField(value: self.invalidationID, fieldNumber: 1)
    }
    if self.invalidationNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.invalidationNonce, fieldNumber: 2)
    }
    if !self.ethSigner.isEmpty {
      try visitor.visitSingularStringField(value: self.ethSigner, fieldNumber: 3)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 4)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgConfirmLogicCall, rhs: Gravity_V1_MsgConfirmLogicCall) -> Bool {
    if lhs.invalidationID != rhs.invalidationID {return false}
    if lhs.invalidationNonce != rhs.invalidationNonce {return false}
    if lhs.ethSigner != rhs.ethSigner {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgConfirmLogicCallResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgConfirmLogicCallResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgConfirmLogicCallResponse, rhs: Gravity_V1_MsgConfirmLogicCallResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgDepositClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "token_contract"),
    4: .same(proto: "amount"),
    5: .standard(proto: "ethereum_sender"),
    6: .standard(proto: "cosmos_receiver"),
    7: .same(proto: "orchestrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.eventNonce)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 3: try decoder.decodeSingularStringField(value: &self.tokenContract)
      case 4: try decoder.decodeSingularStringField(value: &self.amount)
      case 5: try decoder.decodeSingularStringField(value: &self.ethereumSender)
      case 6: try decoder.decodeSingularStringField(value: &self.cosmosReceiver)
      case 7: try decoder.decodeSingularStringField(value: &self.orchestrator)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitSingularStringField(value: self.amount, fieldNumber: 4)
    }
    if !self.ethereumSender.isEmpty {
      try visitor.visitSingularStringField(value: self.ethereumSender, fieldNumber: 5)
    }
    if !self.cosmosReceiver.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosReceiver, fieldNumber: 6)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgDepositClaim, rhs: Gravity_V1_MsgDepositClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.ethereumSender != rhs.ethereumSender {return false}
    if lhs.cosmosReceiver != rhs.cosmosReceiver {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgDepositClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgDepositClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgDepositClaimResponse, rhs: Gravity_V1_MsgDepositClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgWithdrawClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "batch_nonce"),
    4: .standard(proto: "token_contract"),
    5: .same(proto: "orchestrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.eventNonce)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.batchNonce)
      case 4: try decoder.decodeSingularStringField(value: &self.tokenContract)
      case 5: try decoder.decodeSingularStringField(value: &self.orchestrator)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    if self.batchNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.batchNonce, fieldNumber: 3)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 4)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgWithdrawClaim, rhs: Gravity_V1_MsgWithdrawClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.batchNonce != rhs.batchNonce {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgWithdrawClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgWithdrawClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgWithdrawClaimResponse, rhs: Gravity_V1_MsgWithdrawClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgERC20DeployedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgERC20DeployedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "cosmos_denom"),
    4: .standard(proto: "token_contract"),
    5: .same(proto: "name"),
    6: .same(proto: "symbol"),
    7: .same(proto: "decimals"),
    8: .same(proto: "orchestrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.eventNonce)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 3: try decoder.decodeSingularStringField(value: &self.cosmosDenom)
      case 4: try decoder.decodeSingularStringField(value: &self.tokenContract)
      case 5: try decoder.decodeSingularStringField(value: &self.name)
      case 6: try decoder.decodeSingularStringField(value: &self.symbol)
      case 7: try decoder.decodeSingularUInt64Field(value: &self.decimals)
      case 8: try decoder.decodeSingularStringField(value: &self.orchestrator)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    if !self.cosmosDenom.isEmpty {
      try visitor.visitSingularStringField(value: self.cosmosDenom, fieldNumber: 3)
    }
    if !self.tokenContract.isEmpty {
      try visitor.visitSingularStringField(value: self.tokenContract, fieldNumber: 4)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 5)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 6)
    }
    if self.decimals != 0 {
      try visitor.visitSingularUInt64Field(value: self.decimals, fieldNumber: 7)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgERC20DeployedClaim, rhs: Gravity_V1_MsgERC20DeployedClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.cosmosDenom != rhs.cosmosDenom {return false}
    if lhs.tokenContract != rhs.tokenContract {return false}
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.decimals != rhs.decimals {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgERC20DeployedClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgERC20DeployedClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgERC20DeployedClaimResponse, rhs: Gravity_V1_MsgERC20DeployedClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgLogicCallExecutedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLogicCallExecutedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "block_height"),
    3: .standard(proto: "invalidation_id"),
    4: .standard(proto: "invalidation_nonce"),
    5: .same(proto: "orchestrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.eventNonce)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 3: try decoder.decodeSingularBytesField(value: &self.invalidationID)
      case 4: try decoder.decodeSingularUInt64Field(value: &self.invalidationNonce)
      case 5: try decoder.decodeSingularStringField(value: &self.orchestrator)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 2)
    }
    if !self.invalidationID.isEmpty {
      try visitor.visitSingularBytesField(value: self.invalidationID, fieldNumber: 3)
    }
    if self.invalidationNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.invalidationNonce, fieldNumber: 4)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgLogicCallExecutedClaim, rhs: Gravity_V1_MsgLogicCallExecutedClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.invalidationID != rhs.invalidationID {return false}
    if lhs.invalidationNonce != rhs.invalidationNonce {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgLogicCallExecutedClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgLogicCallExecutedClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgLogicCallExecutedClaimResponse, rhs: Gravity_V1_MsgLogicCallExecutedClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgValsetUpdatedClaim: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgValsetUpdatedClaim"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "event_nonce"),
    2: .standard(proto: "valset_nonce"),
    3: .standard(proto: "block_height"),
    4: .same(proto: "members"),
    6: .same(proto: "orchestrator"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.eventNonce)
      case 2: try decoder.decodeSingularUInt64Field(value: &self.valsetNonce)
      case 3: try decoder.decodeSingularUInt64Field(value: &self.blockHeight)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.members)
      case 6: try decoder.decodeSingularStringField(value: &self.orchestrator)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.eventNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.eventNonce, fieldNumber: 1)
    }
    if self.valsetNonce != 0 {
      try visitor.visitSingularUInt64Field(value: self.valsetNonce, fieldNumber: 2)
    }
    if self.blockHeight != 0 {
      try visitor.visitSingularUInt64Field(value: self.blockHeight, fieldNumber: 3)
    }
    if !self.members.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.members, fieldNumber: 4)
    }
    if !self.orchestrator.isEmpty {
      try visitor.visitSingularStringField(value: self.orchestrator, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgValsetUpdatedClaim, rhs: Gravity_V1_MsgValsetUpdatedClaim) -> Bool {
    if lhs.eventNonce != rhs.eventNonce {return false}
    if lhs.valsetNonce != rhs.valsetNonce {return false}
    if lhs.blockHeight != rhs.blockHeight {return false}
    if lhs.members != rhs.members {return false}
    if lhs.orchestrator != rhs.orchestrator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgValsetUpdatedClaimResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgValsetUpdatedClaimResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgValsetUpdatedClaimResponse, rhs: Gravity_V1_MsgValsetUpdatedClaimResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgCancelSendToEth: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSendToEth"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "transaction_id"),
    2: .same(proto: "sender"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularUInt64Field(value: &self.transactionID)
      case 2: try decoder.decodeSingularStringField(value: &self.sender)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.transactionID != 0 {
      try visitor.visitSingularUInt64Field(value: self.transactionID, fieldNumber: 1)
    }
    if !self.sender.isEmpty {
      try visitor.visitSingularStringField(value: self.sender, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgCancelSendToEth, rhs: Gravity_V1_MsgCancelSendToEth) -> Bool {
    if lhs.transactionID != rhs.transactionID {return false}
    if lhs.sender != rhs.sender {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgCancelSendToEthResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgCancelSendToEthResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgCancelSendToEthResponse, rhs: Gravity_V1_MsgCancelSendToEthResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSubmitBadSignatureEvidence: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubmitBadSignatureEvidence"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "subject"),
    2: .same(proto: "signature"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._subject)
      case 2: try decoder.decodeSingularStringField(value: &self.signature)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._subject {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularStringField(value: self.signature, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSubmitBadSignatureEvidence, rhs: Gravity_V1_MsgSubmitBadSignatureEvidence) -> Bool {
    if lhs._subject != rhs._subject {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Gravity_V1_MsgSubmitBadSignatureEvidenceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MsgSubmitBadSignatureEvidenceResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Gravity_V1_MsgSubmitBadSignatureEvidenceResponse, rhs: Gravity_V1_MsgSubmitBadSignatureEvidenceResponse) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
