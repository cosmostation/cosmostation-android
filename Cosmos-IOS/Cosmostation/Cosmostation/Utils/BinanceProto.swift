// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: dex.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// please note the field name is the JSON name.
struct BinanceStdTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    uint64 SIZE-OF-ENCODED // varint encoded length of the structure after encoding
  ///    0xF0625DEE   // hardcoded, object type prefix in 4 bytes
  var msgs: [Data] = []

  /// array of size 1, containing the standard signature structure of the transaction sender
  var signatures: [Data] = []

  /// a short sentence of remark for the transaction. Please only `Transfer` transaction allows 'memo' input, and other transactions with non-empty `Memo` would be rejected.
  var memo: String = String()

  /// an identifier for tools triggerring this transaction, set to zero if unwilling to disclose.
  var source: Int64 = 0

  ///byte array, reserved for future use
  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct StdSignature {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// public key bytes of the signer address
  var pubKey: Data = SwiftProtobuf.Internal.emptyData

  /// signature bytes, please check chain access section for signature generation
  var signature: Data = SwiftProtobuf.Internal.emptyData

  /// another identifier of signer, which can be read from chain by account REST API or RPC
  var accountNumber: Int64 = 0

  /// sequence number for the next transaction of the client, which can be read fro chain by account REST API or RPC. please check chain acces section for details.
  var sequence: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// please note there is no type prefix for StdSignature
  struct PubKey {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// please note the field name is the JSON name.
/// msg
struct NewOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0xCE6DC043 // hardcoded, object type prefix in 4 bytes
  var sender: Data = SwiftProtobuf.Internal.emptyData

  /// order id, optional
  var id: String = String()

  /// symbol for trading pair in full name of the tokens
  var symbol: String = String()

  /// only accept 2 for now, meaning limit order
  var ordertype: Int64 = 0

  /// 1 for buy and 2 fory sell
  var side: Int64 = 0

  /// price of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer
  var price: Int64 = 0

  /// quantity of the order, which is the real price multiplied by 1e8 (10^8) and rounded to integer
  var quantity: Int64 = 0

  /// 1 for Good Till Expire(GTE) order and 3 for Immediate Or Cancel (IOC)
  var timeinforce: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// please note the field name is the JSON name.
/// msg
struct CancelOrder {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0x166E681B   // hardcoded, object type prefix in 4 bytes
  var sender: Data = SwiftProtobuf.Internal.emptyData

  /// symbol for trading pair in full name of the tokens
  var symbol: String = String()

  /// order id of the one to cancel
  var refid: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// please note the field name is the JSON name.
/// msg
struct TokenFreeze {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0xE774B32D   // hardcoded, object type prefix in 4 bytes
  var from: Data = SwiftProtobuf.Internal.emptyData

  /// token symbol, in full name with "-" suffix
  var symbol: String = String()

  /// amount of token to freeze
  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// please note the field name is the JSON name.
/// msg
struct TokenUnfreeze {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0x6515FF0D   // hardcoded, object type prefix in 4 bytes
  var from: Data = SwiftProtobuf.Internal.emptyData

  /// token symbol, in full name with "-" suffix
  var symbol: String = String()

  /// amount of token to freeze
  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// please note the field name is the JSON name.
/// msg
struct Send {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var inputs: [Send.Input] = []

  var outputs: [Send.Output] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///    0x2A2C87FA   // hardcoded, object type prefix in 4 bytes
  struct Token {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var denom: String = String()

    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Input {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = SwiftProtobuf.Internal.emptyData

    var coins: [Send.Token] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  struct Output {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = SwiftProtobuf.Internal.emptyData

    var coins: [Send.Token] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// please note the field name is the JSON name.
/// msg
struct BinanceVote {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0xA1CADD36        // hardcoded, object type prefix in 4 bytes
  var proposalID: Int64 = 0

  /// address of the voter
  var voter: Data = SwiftProtobuf.Internal.emptyData

  /// option from OptionSet chosen by the voter,
  var option: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Token {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var denom: String = String()

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct AppAccount {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var base: AppAccount.baseAccount {
    get {return _base ?? AppAccount.baseAccount()}
    set {_base = newValue}
  }
  /// Returns true if `base` has been explicitly set.
  var hasBase: Bool {return self._base != nil}
  /// Clears the value of `base`. Subsequent reads from it will return its default value.
  mutating func clearBase() {self._base = nil}

  var name: String = String()

  var frozen: [Token] = []

  var locked: [Token] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  ///    uint64 SIZE-OF-ENCODED // varint encoded length of the structure after encoding
  ///    0x4BDC4C27   // hardcoded, object type prefix in 4 bytes
  struct baseAccount {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var address: Data = SwiftProtobuf.Internal.emptyData

    var coins: [Token] = []

    var publicKey: Data = SwiftProtobuf.Internal.emptyData

    var accountNumber: Int64 = 0

    var sequence: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}

  fileprivate var _base: AppAccount.baseAccount? = nil
}

struct AtomicSwapInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Data = SwiftProtobuf.Internal.emptyData

  var to: Data = SwiftProtobuf.Internal.emptyData

  var outAmount: [Token] = []

  var inAmount: [Token] = []

  var expectedIncome: String = String()

  var recipientOtherChain: Data = SwiftProtobuf.Internal.emptyData

  var randomNumberHash: Data = SwiftProtobuf.Internal.emptyData

  var randomNumber: Data = SwiftProtobuf.Internal.emptyData

  var timestamp: Int64 = 0

  var crossChain: Bool = false

  var expireHeight: Int64 = 0

  var index: Int64 = 0

  var closedTime: Int64 = 0

  var status: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TokenInfo {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var name: String = String()

  var symbol: String = String()

  var originalSymbol: String = String()

  var totalSupply: Int64 = 0

  var owner: Data = SwiftProtobuf.Internal.emptyData

  var mintable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DexFeeParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dexFeeFields: [DexFeeParam.DexFeeField] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  /// 0x495A5044
  struct DexFeeField {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var feeName: String = String()

    var feeValue: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

/// sync/async response
struct ResultBroadcastTx {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///uint32
  var code: Int32 = 0

  var data: Data = SwiftProtobuf.Internal.emptyData

  var log: String = String()

  var hash: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Issue {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0x17EFAB80 // hardcoded, object type prefix in 4 bytes
  var from: Data = SwiftProtobuf.Internal.emptyData

  var name: String = String()

  var symbol: String = String()

  var totalSupply: Int64 = 0

  var mintable: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Burn {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///    0x7ED2D2A0 // hardcoded, object type prefix in 4 bytes
  var from: Data = SwiftProtobuf.Internal.emptyData

  var symbol: String = String()

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Mint {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0x467E0829
  var from: Data = SwiftProtobuf.Internal.emptyData

  var symbol: String = String()

  var amount: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SubmitProposal {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0xB42D614E
  var title: String = String()

  var description_p: String = String()

  var proposalType: Int64 = 0

  var proposer: Data = SwiftProtobuf.Internal.emptyData

  var initialDeposit: [Token] = []

  var votingPeriod: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Deposit {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0xA18A56E5
  var proposalID: Int64 = 0

  var depositer: Data = SwiftProtobuf.Internal.emptyData

  var amount: [Token] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Description {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var moniker: String = String()

  var identity: String = String()

  var website: String = String()

  var details: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Commission {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var rate: Int64 = 0

  var maxRate: Int64 = 0

  var maxChangeRate: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct CreateValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0xEB361D01
  var description_p: Description {
    get {return _description_p ?? Description()}
    set {_description_p = newValue}
  }
  /// Returns true if `description_p` has been explicitly set.
  var hasDescription_p: Bool {return self._description_p != nil}
  /// Clears the value of `description_p`. Subsequent reads from it will return its default value.
  mutating func clearDescription_p() {self._description_p = nil}

  var commission: Commission {
    get {return _commission ?? Commission()}
    set {_commission = newValue}
  }
  /// Returns true if `commission` has been explicitly set.
  var hasCommission: Bool {return self._commission != nil}
  /// Clears the value of `commission`. Subsequent reads from it will return its default value.
  mutating func clearCommission() {self._commission = nil}

  var delegatorAddress: Data = SwiftProtobuf.Internal.emptyData

  var validatorAddress: Data = SwiftProtobuf.Internal.emptyData

  var pubkey: Data = SwiftProtobuf.Internal.emptyData

  var delegation: Token {
    get {return _delegation ?? Token()}
    set {_delegation = newValue}
  }
  /// Returns true if `delegation` has been explicitly set.
  var hasDelegation: Bool {return self._delegation != nil}
  /// Clears the value of `delegation`. Subsequent reads from it will return its default value.
  mutating func clearDelegation() {self._delegation = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _description_p: Description? = nil
  fileprivate var _commission: Commission? = nil
  fileprivate var _delegation: Token? = nil
}

struct RealCreateValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0xDB6A19FD
  var createValidator: CreateValidator {
    get {return _createValidator ?? CreateValidator()}
    set {_createValidator = newValue}
  }
  /// Returns true if `createValidator` has been explicitly set.
  var hasCreateValidator: Bool {return self._createValidator != nil}
  /// Clears the value of `createValidator`. Subsequent reads from it will return its default value.
  mutating func clearCreateValidator() {self._createValidator = nil}

  var proposalID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _createValidator: CreateValidator? = nil
}

struct RemoveValidator {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  ///0xC1AFE85F
  var launcherAddr: Data = SwiftProtobuf.Internal.emptyData

  var valAddr: Data = SwiftProtobuf.Internal.emptyData

  var valConsAddr: Data = SwiftProtobuf.Internal.emptyData

  var proposalID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct List {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 0xB41DE13F
  var from: Data = SwiftProtobuf.Internal.emptyData

  var proposalID: Int64 = 0

  var baseAssetSymbol: String = String()

  var quoteAssetSymbol: String = String()

  var initPrice: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TimeLock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 07921531
  var from: Data = SwiftProtobuf.Internal.emptyData

  var description_p: String = String()

  var amount: [TimeLock.Token] = []

  var lockTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Token {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var denom: String = String()

    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct TimeUnlock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// C4050C6C
  var from: Data = SwiftProtobuf.Internal.emptyData

  var timeLockID: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TimeRelock {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// 504711DA
  var from: Data = SwiftProtobuf.Internal.emptyData

  var timeLockID: Int64 = 0

  var description_p: String = String()

  var amount: [TimeRelock.Token] = []

  var lockTime: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Token {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var denom: String = String()

    var amount: Int64 = 0

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}
  }

  init() {}
}

struct SetAccountFlag {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// BEA6E301
  var from: Data = SwiftProtobuf.Internal.emptyData

  var flags: Int64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HashTimerLockTransferMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Data = SwiftProtobuf.Internal.emptyData

  var to: Data = SwiftProtobuf.Internal.emptyData

  var recipientOtherChain: String = String()

  var senderOtherChain: String = String()

  var randomNumberHash: Data = SwiftProtobuf.Internal.emptyData

  var timestamp: Int64 = 0

  var amount: [Token] = []

  var expectedIncome: String = String()

  var heightSpan: Int64 = 0

  var crossChain: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct DepositHashTimerLockMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Data = SwiftProtobuf.Internal.emptyData

  var amount: [Token] = []

  var swapID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ClaimHashTimerLockMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Data = SwiftProtobuf.Internal.emptyData

  var swapID: Data = SwiftProtobuf.Internal.emptyData

  var randomNumber: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RefundHashTimerLockMsg {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var from: Data = SwiftProtobuf.Internal.emptyData

  var swapID: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension BinanceStdTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StdTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "msgs"),
    2: .same(proto: "signatures"),
    3: .same(proto: "memo"),
    4: .same(proto: "source"),
    5: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedBytesField(value: &self.msgs)
      case 2: try decoder.decodeRepeatedBytesField(value: &self.signatures)
      case 3: try decoder.decodeSingularStringField(value: &self.memo)
      case 4: try decoder.decodeSingularInt64Field(value: &self.source)
      case 5: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.msgs.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.msgs, fieldNumber: 1)
    }
    if !self.signatures.isEmpty {
      try visitor.visitRepeatedBytesField(value: self.signatures, fieldNumber: 2)
    }
    if !self.memo.isEmpty {
      try visitor.visitSingularStringField(value: self.memo, fieldNumber: 3)
    }
    if self.source != 0 {
      try visitor.visitSingularInt64Field(value: self.source, fieldNumber: 4)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BinanceStdTx, rhs: BinanceStdTx) -> Bool {
    if lhs.msgs != rhs.msgs {return false}
    if lhs.signatures != rhs.signatures {return false}
    if lhs.memo != rhs.memo {return false}
    if lhs.source != rhs.source {return false}
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StdSignature: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "StdSignature"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "pub_key"),
    2: .same(proto: "signature"),
    3: .standard(proto: "account_number"),
    4: .same(proto: "sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.pubKey)
      case 2: try decoder.decodeSingularBytesField(value: &self.signature)
      case 3: try decoder.decodeSingularInt64Field(value: &self.accountNumber)
      case 4: try decoder.decodeSingularInt64Field(value: &self.sequence)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.pubKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubKey, fieldNumber: 1)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 2)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.accountNumber, fieldNumber: 3)
    }
    if self.sequence != 0 {
      try visitor.visitSingularInt64Field(value: self.sequence, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StdSignature, rhs: StdSignature) -> Bool {
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension StdSignature.PubKey: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = StdSignature.protoMessageName + ".PubKey"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: StdSignature.PubKey, rhs: StdSignature.PubKey) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension NewOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "NewOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "id"),
    3: .same(proto: "symbol"),
    4: .same(proto: "ordertype"),
    5: .same(proto: "side"),
    6: .same(proto: "price"),
    7: .same(proto: "quantity"),
    8: .same(proto: "timeinforce"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.sender)
      case 2: try decoder.decodeSingularStringField(value: &self.id)
      case 3: try decoder.decodeSingularStringField(value: &self.symbol)
      case 4: try decoder.decodeSingularInt64Field(value: &self.ordertype)
      case 5: try decoder.decodeSingularInt64Field(value: &self.side)
      case 6: try decoder.decodeSingularInt64Field(value: &self.price)
      case 7: try decoder.decodeSingularInt64Field(value: &self.quantity)
      case 8: try decoder.decodeSingularInt64Field(value: &self.timeinforce)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 2)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 3)
    }
    if self.ordertype != 0 {
      try visitor.visitSingularInt64Field(value: self.ordertype, fieldNumber: 4)
    }
    if self.side != 0 {
      try visitor.visitSingularInt64Field(value: self.side, fieldNumber: 5)
    }
    if self.price != 0 {
      try visitor.visitSingularInt64Field(value: self.price, fieldNumber: 6)
    }
    if self.quantity != 0 {
      try visitor.visitSingularInt64Field(value: self.quantity, fieldNumber: 7)
    }
    if self.timeinforce != 0 {
      try visitor.visitSingularInt64Field(value: self.timeinforce, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: NewOrder, rhs: NewOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.id != rhs.id {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.ordertype != rhs.ordertype {return false}
    if lhs.side != rhs.side {return false}
    if lhs.price != rhs.price {return false}
    if lhs.quantity != rhs.quantity {return false}
    if lhs.timeinforce != rhs.timeinforce {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CancelOrder: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CancelOrder"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sender"),
    2: .same(proto: "symbol"),
    3: .same(proto: "refid"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.sender)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularStringField(value: &self.refid)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sender.isEmpty {
      try visitor.visitSingularBytesField(value: self.sender, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.refid.isEmpty {
      try visitor.visitSingularStringField(value: self.refid, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CancelOrder, rhs: CancelOrder) -> Bool {
    if lhs.sender != rhs.sender {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.refid != rhs.refid {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TokenFreeze: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TokenFreeze"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "symbol"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TokenFreeze, rhs: TokenFreeze) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TokenUnfreeze: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TokenUnfreeze"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "symbol"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TokenUnfreeze, rhs: TokenUnfreeze) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Send: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Send"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "inputs"),
    2: .same(proto: "outputs"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.inputs)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.outputs)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.inputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inputs, fieldNumber: 1)
    }
    if !self.outputs.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outputs, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Send, rhs: Send) -> Bool {
    if lhs.inputs != rhs.inputs {return false}
    if lhs.outputs != rhs.outputs {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Send.Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Send.protoMessageName + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.denom)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Send.Token, rhs: Send.Token) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Send.Input: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Send.protoMessageName + ".Input"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.coins)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Send.Input, rhs: Send.Input) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.coins != rhs.coins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Send.Output: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Send.protoMessageName + ".Output"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "coins"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.coins)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Send.Output, rhs: Send.Output) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.coins != rhs.coins {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension BinanceVote: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Vote"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .same(proto: "voter"),
    3: .same(proto: "option"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      case 2: try decoder.decodeSingularBytesField(value: &self.voter)
      case 3: try decoder.decodeSingularInt64Field(value: &self.option)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.voter.isEmpty {
      try visitor.visitSingularBytesField(value: self.voter, fieldNumber: 2)
    }
    if self.option != 0 {
      try visitor.visitSingularInt64Field(value: self.option, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: BinanceVote, rhs: BinanceVote) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.voter != rhs.voter {return false}
    if lhs.option != rhs.option {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.denom)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Token, rhs: Token) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AppAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AppAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "base"),
    2: .same(proto: "name"),
    3: .same(proto: "frozen"),
    4: .same(proto: "locked"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._base)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.frozen)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.locked)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._base {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.frozen.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.frozen, fieldNumber: 3)
    }
    if !self.locked.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.locked, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppAccount, rhs: AppAccount) -> Bool {
    if lhs._base != rhs._base {return false}
    if lhs.name != rhs.name {return false}
    if lhs.frozen != rhs.frozen {return false}
    if lhs.locked != rhs.locked {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AppAccount.baseAccount: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = AppAccount.protoMessageName + ".baseAccount"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "coins"),
    3: .standard(proto: "public_key"),
    4: .standard(proto: "account_number"),
    5: .same(proto: "sequence"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.address)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.coins)
      case 3: try decoder.decodeSingularBytesField(value: &self.publicKey)
      case 4: try decoder.decodeSingularInt64Field(value: &self.accountNumber)
      case 5: try decoder.decodeSingularInt64Field(value: &self.sequence)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularBytesField(value: self.address, fieldNumber: 1)
    }
    if !self.coins.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.coins, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    if self.accountNumber != 0 {
      try visitor.visitSingularInt64Field(value: self.accountNumber, fieldNumber: 4)
    }
    if self.sequence != 0 {
      try visitor.visitSingularInt64Field(value: self.sequence, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AppAccount.baseAccount, rhs: AppAccount.baseAccount) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.coins != rhs.coins {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.accountNumber != rhs.accountNumber {return false}
    if lhs.sequence != rhs.sequence {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension AtomicSwapInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "AtomicSwapInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "out_amount"),
    4: .standard(proto: "in_amount"),
    5: .standard(proto: "expected_income"),
    6: .standard(proto: "recipient_other_chain"),
    7: .standard(proto: "random_number_hash"),
    8: .standard(proto: "random_number"),
    9: .same(proto: "timestamp"),
    10: .standard(proto: "cross_chain"),
    11: .standard(proto: "expire_height"),
    12: .same(proto: "index"),
    13: .standard(proto: "closed_time"),
    14: .same(proto: "status"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularBytesField(value: &self.to)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.outAmount)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.inAmount)
      case 5: try decoder.decodeSingularStringField(value: &self.expectedIncome)
      case 6: try decoder.decodeSingularBytesField(value: &self.recipientOtherChain)
      case 7: try decoder.decodeSingularBytesField(value: &self.randomNumberHash)
      case 8: try decoder.decodeSingularBytesField(value: &self.randomNumber)
      case 9: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 10: try decoder.decodeSingularBoolField(value: &self.crossChain)
      case 11: try decoder.decodeSingularInt64Field(value: &self.expireHeight)
      case 12: try decoder.decodeSingularInt64Field(value: &self.index)
      case 13: try decoder.decodeSingularInt64Field(value: &self.closedTime)
      case 14: try decoder.decodeSingularInt32Field(value: &self.status)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    if !self.outAmount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.outAmount, fieldNumber: 3)
    }
    if !self.inAmount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.inAmount, fieldNumber: 4)
    }
    if !self.expectedIncome.isEmpty {
      try visitor.visitSingularStringField(value: self.expectedIncome, fieldNumber: 5)
    }
    if !self.recipientOtherChain.isEmpty {
      try visitor.visitSingularBytesField(value: self.recipientOtherChain, fieldNumber: 6)
    }
    if !self.randomNumberHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomNumberHash, fieldNumber: 7)
    }
    if !self.randomNumber.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomNumber, fieldNumber: 8)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 9)
    }
    if self.crossChain != false {
      try visitor.visitSingularBoolField(value: self.crossChain, fieldNumber: 10)
    }
    if self.expireHeight != 0 {
      try visitor.visitSingularInt64Field(value: self.expireHeight, fieldNumber: 11)
    }
    if self.index != 0 {
      try visitor.visitSingularInt64Field(value: self.index, fieldNumber: 12)
    }
    if self.closedTime != 0 {
      try visitor.visitSingularInt64Field(value: self.closedTime, fieldNumber: 13)
    }
    if self.status != 0 {
      try visitor.visitSingularInt32Field(value: self.status, fieldNumber: 14)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: AtomicSwapInfo, rhs: AtomicSwapInfo) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.outAmount != rhs.outAmount {return false}
    if lhs.inAmount != rhs.inAmount {return false}
    if lhs.expectedIncome != rhs.expectedIncome {return false}
    if lhs.recipientOtherChain != rhs.recipientOtherChain {return false}
    if lhs.randomNumberHash != rhs.randomNumberHash {return false}
    if lhs.randomNumber != rhs.randomNumber {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.crossChain != rhs.crossChain {return false}
    if lhs.expireHeight != rhs.expireHeight {return false}
    if lhs.index != rhs.index {return false}
    if lhs.closedTime != rhs.closedTime {return false}
    if lhs.status != rhs.status {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TokenInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TokenInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "symbol"),
    3: .standard(proto: "original_symbol"),
    4: .standard(proto: "total_supply"),
    5: .same(proto: "owner"),
    6: .same(proto: "mintable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.name)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularStringField(value: &self.originalSymbol)
      case 4: try decoder.decodeSingularInt64Field(value: &self.totalSupply)
      case 5: try decoder.decodeSingularBytesField(value: &self.owner)
      case 6: try decoder.decodeSingularBoolField(value: &self.mintable)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if !self.originalSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.originalSymbol, fieldNumber: 3)
    }
    if self.totalSupply != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSupply, fieldNumber: 4)
    }
    if !self.owner.isEmpty {
      try visitor.visitSingularBytesField(value: self.owner, fieldNumber: 5)
    }
    if self.mintable != false {
      try visitor.visitSingularBoolField(value: self.mintable, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TokenInfo, rhs: TokenInfo) -> Bool {
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.originalSymbol != rhs.originalSymbol {return false}
    if lhs.totalSupply != rhs.totalSupply {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.mintable != rhs.mintable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DexFeeParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DexFeeParam"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "dex_fee_fields"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.dexFeeFields)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.dexFeeFields.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.dexFeeFields, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DexFeeParam, rhs: DexFeeParam) -> Bool {
    if lhs.dexFeeFields != rhs.dexFeeFields {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DexFeeParam.DexFeeField: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = DexFeeParam.protoMessageName + ".DexFeeField"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "fee_name"),
    2: .standard(proto: "fee_value"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.feeName)
      case 2: try decoder.decodeSingularInt64Field(value: &self.feeValue)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.feeName.isEmpty {
      try visitor.visitSingularStringField(value: self.feeName, fieldNumber: 1)
    }
    if self.feeValue != 0 {
      try visitor.visitSingularInt64Field(value: self.feeValue, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DexFeeParam.DexFeeField, rhs: DexFeeParam.DexFeeField) -> Bool {
    if lhs.feeName != rhs.feeName {return false}
    if lhs.feeValue != rhs.feeValue {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResultBroadcastTx: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResultBroadcastTx"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "data"),
    3: .same(proto: "log"),
    4: .same(proto: "hash"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.code)
      case 2: try decoder.decodeSingularBytesField(value: &self.data)
      case 3: try decoder.decodeSingularStringField(value: &self.log)
      case 4: try decoder.decodeSingularBytesField(value: &self.hash)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.code != 0 {
      try visitor.visitSingularInt32Field(value: self.code, fieldNumber: 1)
    }
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 2)
    }
    if !self.log.isEmpty {
      try visitor.visitSingularStringField(value: self.log, fieldNumber: 3)
    }
    if !self.hash.isEmpty {
      try visitor.visitSingularBytesField(value: self.hash, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResultBroadcastTx, rhs: ResultBroadcastTx) -> Bool {
    if lhs.code != rhs.code {return false}
    if lhs.data != rhs.data {return false}
    if lhs.log != rhs.log {return false}
    if lhs.hash != rhs.hash {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Issue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Issue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "name"),
    3: .same(proto: "symbol"),
    4: .standard(proto: "total_supply"),
    5: .same(proto: "mintable"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.symbol)
      case 4: try decoder.decodeSingularInt64Field(value: &self.totalSupply)
      case 5: try decoder.decodeSingularBoolField(value: &self.mintable)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 3)
    }
    if self.totalSupply != 0 {
      try visitor.visitSingularInt64Field(value: self.totalSupply, fieldNumber: 4)
    }
    if self.mintable != false {
      try visitor.visitSingularBoolField(value: self.mintable, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Issue, rhs: Issue) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.name != rhs.name {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.totalSupply != rhs.totalSupply {return false}
    if lhs.mintable != rhs.mintable {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Burn: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Burn"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "symbol"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Burn, rhs: Burn) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Mint: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Mint"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "symbol"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.symbol)
      case 3: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.symbol.isEmpty {
      try visitor.visitSingularStringField(value: self.symbol, fieldNumber: 2)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Mint, rhs: Mint) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.symbol != rhs.symbol {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SubmitProposal: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SubmitProposal"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "description"),
    3: .standard(proto: "proposal_type"),
    4: .same(proto: "proposer"),
    5: .standard(proto: "initial_deposit"),
    6: .standard(proto: "voting_period"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.title)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeSingularInt64Field(value: &self.proposalType)
      case 4: try decoder.decodeSingularBytesField(value: &self.proposer)
      case 5: try decoder.decodeRepeatedMessageField(value: &self.initialDeposit)
      case 6: try decoder.decodeSingularInt64Field(value: &self.votingPeriod)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if self.proposalType != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalType, fieldNumber: 3)
    }
    if !self.proposer.isEmpty {
      try visitor.visitSingularBytesField(value: self.proposer, fieldNumber: 4)
    }
    if !self.initialDeposit.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.initialDeposit, fieldNumber: 5)
    }
    if self.votingPeriod != 0 {
      try visitor.visitSingularInt64Field(value: self.votingPeriod, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SubmitProposal, rhs: SubmitProposal) -> Bool {
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.proposalType != rhs.proposalType {return false}
    if lhs.proposer != rhs.proposer {return false}
    if lhs.initialDeposit != rhs.initialDeposit {return false}
    if lhs.votingPeriod != rhs.votingPeriod {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Deposit: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Deposit"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "proposal_id"),
    2: .same(proto: "depositer"),
    3: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      case 2: try decoder.decodeSingularBytesField(value: &self.depositer)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 1)
    }
    if !self.depositer.isEmpty {
      try visitor.visitSingularBytesField(value: self.depositer, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Deposit, rhs: Deposit) -> Bool {
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.depositer != rhs.depositer {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Description: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Description"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "moniker"),
    2: .same(proto: "identity"),
    3: .same(proto: "website"),
    4: .same(proto: "details"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.moniker)
      case 2: try decoder.decodeSingularStringField(value: &self.identity)
      case 3: try decoder.decodeSingularStringField(value: &self.website)
      case 4: try decoder.decodeSingularStringField(value: &self.details)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.moniker.isEmpty {
      try visitor.visitSingularStringField(value: self.moniker, fieldNumber: 1)
    }
    if !self.identity.isEmpty {
      try visitor.visitSingularStringField(value: self.identity, fieldNumber: 2)
    }
    if !self.website.isEmpty {
      try visitor.visitSingularStringField(value: self.website, fieldNumber: 3)
    }
    if !self.details.isEmpty {
      try visitor.visitSingularStringField(value: self.details, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Description, rhs: Description) -> Bool {
    if lhs.moniker != rhs.moniker {return false}
    if lhs.identity != rhs.identity {return false}
    if lhs.website != rhs.website {return false}
    if lhs.details != rhs.details {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Commission: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "Commission"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "rate"),
    2: .standard(proto: "max_rate"),
    3: .standard(proto: "max_change_rate"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt64Field(value: &self.rate)
      case 2: try decoder.decodeSingularInt64Field(value: &self.maxRate)
      case 3: try decoder.decodeSingularInt64Field(value: &self.maxChangeRate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.rate != 0 {
      try visitor.visitSingularInt64Field(value: self.rate, fieldNumber: 1)
    }
    if self.maxRate != 0 {
      try visitor.visitSingularInt64Field(value: self.maxRate, fieldNumber: 2)
    }
    if self.maxChangeRate != 0 {
      try visitor.visitSingularInt64Field(value: self.maxChangeRate, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Commission, rhs: Commission) -> Bool {
    if lhs.rate != rhs.rate {return false}
    if lhs.maxRate != rhs.maxRate {return false}
    if lhs.maxChangeRate != rhs.maxChangeRate {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CreateValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "CreateValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "description"),
    2: .same(proto: "commission"),
    3: .standard(proto: "delegator_address"),
    4: .standard(proto: "validator_address"),
    5: .same(proto: "pubkey"),
    6: .same(proto: "delegation"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._description_p)
      case 2: try decoder.decodeSingularMessageField(value: &self._commission)
      case 3: try decoder.decodeSingularBytesField(value: &self.delegatorAddress)
      case 4: try decoder.decodeSingularBytesField(value: &self.validatorAddress)
      case 5: try decoder.decodeSingularBytesField(value: &self.pubkey)
      case 6: try decoder.decodeSingularMessageField(value: &self._delegation)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._description_p {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if let v = self._commission {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }
    if !self.delegatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.delegatorAddress, fieldNumber: 3)
    }
    if !self.validatorAddress.isEmpty {
      try visitor.visitSingularBytesField(value: self.validatorAddress, fieldNumber: 4)
    }
    if !self.pubkey.isEmpty {
      try visitor.visitSingularBytesField(value: self.pubkey, fieldNumber: 5)
    }
    if let v = self._delegation {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: CreateValidator, rhs: CreateValidator) -> Bool {
    if lhs._description_p != rhs._description_p {return false}
    if lhs._commission != rhs._commission {return false}
    if lhs.delegatorAddress != rhs.delegatorAddress {return false}
    if lhs.validatorAddress != rhs.validatorAddress {return false}
    if lhs.pubkey != rhs.pubkey {return false}
    if lhs._delegation != rhs._delegation {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RealCreateValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RealCreateValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "createValidator"),
    2: .standard(proto: "proposal_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularMessageField(value: &self._createValidator)
      case 2: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if let v = self._createValidator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RealCreateValidator, rhs: RealCreateValidator) -> Bool {
    if lhs._createValidator != rhs._createValidator {return false}
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RemoveValidator: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RemoveValidator"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "launcher_addr"),
    2: .standard(proto: "val_addr"),
    3: .standard(proto: "val_cons_addr"),
    4: .standard(proto: "proposal_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.launcherAddr)
      case 2: try decoder.decodeSingularBytesField(value: &self.valAddr)
      case 3: try decoder.decodeSingularBytesField(value: &self.valConsAddr)
      case 4: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.launcherAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.launcherAddr, fieldNumber: 1)
    }
    if !self.valAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.valAddr, fieldNumber: 2)
    }
    if !self.valConsAddr.isEmpty {
      try visitor.visitSingularBytesField(value: self.valConsAddr, fieldNumber: 3)
    }
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RemoveValidator, rhs: RemoveValidator) -> Bool {
    if lhs.launcherAddr != rhs.launcherAddr {return false}
    if lhs.valAddr != rhs.valAddr {return false}
    if lhs.valConsAddr != rhs.valConsAddr {return false}
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension List: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "List"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .standard(proto: "proposal_id"),
    3: .standard(proto: "base_asset_symbol"),
    4: .standard(proto: "quote_asset_symbol"),
    5: .standard(proto: "init_price"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularInt64Field(value: &self.proposalID)
      case 3: try decoder.decodeSingularStringField(value: &self.baseAssetSymbol)
      case 4: try decoder.decodeSingularStringField(value: &self.quoteAssetSymbol)
      case 5: try decoder.decodeSingularInt64Field(value: &self.initPrice)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if self.proposalID != 0 {
      try visitor.visitSingularInt64Field(value: self.proposalID, fieldNumber: 2)
    }
    if !self.baseAssetSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.baseAssetSymbol, fieldNumber: 3)
    }
    if !self.quoteAssetSymbol.isEmpty {
      try visitor.visitSingularStringField(value: self.quoteAssetSymbol, fieldNumber: 4)
    }
    if self.initPrice != 0 {
      try visitor.visitSingularInt64Field(value: self.initPrice, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: List, rhs: List) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.proposalID != rhs.proposalID {return false}
    if lhs.baseAssetSymbol != rhs.baseAssetSymbol {return false}
    if lhs.quoteAssetSymbol != rhs.quoteAssetSymbol {return false}
    if lhs.initPrice != rhs.initPrice {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeLock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TimeLock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "description"),
    3: .same(proto: "amount"),
    4: .standard(proto: "lock_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularStringField(value: &self.description_p)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.amount)
      case 4: try decoder.decodeSingularInt64Field(value: &self.lockTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 2)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 3)
    }
    if self.lockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lockTime, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeLock, rhs: TimeLock) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.lockTime != rhs.lockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeLock.Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TimeLock.protoMessageName + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.denom)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeLock.Token, rhs: TimeLock.Token) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeUnlock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TimeUnlock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .standard(proto: "time_lock_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timeLockID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if self.timeLockID != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLockID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeUnlock, rhs: TimeUnlock) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.timeLockID != rhs.timeLockID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeRelock: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TimeRelock"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .standard(proto: "time_lock_id"),
    3: .same(proto: "description"),
    4: .same(proto: "amount"),
    5: .standard(proto: "lock_time"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularInt64Field(value: &self.timeLockID)
      case 3: try decoder.decodeSingularStringField(value: &self.description_p)
      case 4: try decoder.decodeRepeatedMessageField(value: &self.amount)
      case 5: try decoder.decodeSingularInt64Field(value: &self.lockTime)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if self.timeLockID != 0 {
      try visitor.visitSingularInt64Field(value: self.timeLockID, fieldNumber: 2)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 3)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 4)
    }
    if self.lockTime != 0 {
      try visitor.visitSingularInt64Field(value: self.lockTime, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeRelock, rhs: TimeRelock) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.timeLockID != rhs.timeLockID {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.lockTime != rhs.lockTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeRelock.Token: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = TimeRelock.protoMessageName + ".Token"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "denom"),
    2: .same(proto: "amount"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.denom)
      case 2: try decoder.decodeSingularInt64Field(value: &self.amount)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.denom.isEmpty {
      try visitor.visitSingularStringField(value: self.denom, fieldNumber: 1)
    }
    if self.amount != 0 {
      try visitor.visitSingularInt64Field(value: self.amount, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeRelock.Token, rhs: TimeRelock.Token) -> Bool {
    if lhs.denom != rhs.denom {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SetAccountFlag: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SetAccountFlag"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "flags"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularInt64Field(value: &self.flags)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if self.flags != 0 {
      try visitor.visitSingularInt64Field(value: self.flags, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SetAccountFlag, rhs: SetAccountFlag) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.flags != rhs.flags {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HashTimerLockTransferMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HashTimerLockTransferMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "to"),
    3: .standard(proto: "recipient_other_chain"),
    4: .standard(proto: "sender_other_chain"),
    5: .standard(proto: "random_number_hash"),
    6: .same(proto: "timestamp"),
    7: .same(proto: "amount"),
    8: .standard(proto: "expected_income"),
    9: .standard(proto: "height_span"),
    10: .standard(proto: "cross_chain"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularBytesField(value: &self.to)
      case 3: try decoder.decodeSingularStringField(value: &self.recipientOtherChain)
      case 4: try decoder.decodeSingularStringField(value: &self.senderOtherChain)
      case 5: try decoder.decodeSingularBytesField(value: &self.randomNumberHash)
      case 6: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 7: try decoder.decodeRepeatedMessageField(value: &self.amount)
      case 8: try decoder.decodeSingularStringField(value: &self.expectedIncome)
      case 9: try decoder.decodeSingularInt64Field(value: &self.heightSpan)
      case 10: try decoder.decodeSingularBoolField(value: &self.crossChain)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.to.isEmpty {
      try visitor.visitSingularBytesField(value: self.to, fieldNumber: 2)
    }
    if !self.recipientOtherChain.isEmpty {
      try visitor.visitSingularStringField(value: self.recipientOtherChain, fieldNumber: 3)
    }
    if !self.senderOtherChain.isEmpty {
      try visitor.visitSingularStringField(value: self.senderOtherChain, fieldNumber: 4)
    }
    if !self.randomNumberHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomNumberHash, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 7)
    }
    if !self.expectedIncome.isEmpty {
      try visitor.visitSingularStringField(value: self.expectedIncome, fieldNumber: 8)
    }
    if self.heightSpan != 0 {
      try visitor.visitSingularInt64Field(value: self.heightSpan, fieldNumber: 9)
    }
    if self.crossChain != false {
      try visitor.visitSingularBoolField(value: self.crossChain, fieldNumber: 10)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HashTimerLockTransferMsg, rhs: HashTimerLockTransferMsg) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.to != rhs.to {return false}
    if lhs.recipientOtherChain != rhs.recipientOtherChain {return false}
    if lhs.senderOtherChain != rhs.senderOtherChain {return false}
    if lhs.randomNumberHash != rhs.randomNumberHash {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.expectedIncome != rhs.expectedIncome {return false}
    if lhs.heightSpan != rhs.heightSpan {return false}
    if lhs.crossChain != rhs.crossChain {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension DepositHashTimerLockMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DepositHashTimerLockMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .same(proto: "amount"),
    3: .standard(proto: "swap_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.amount)
      case 3: try decoder.decodeSingularBytesField(value: &self.swapID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.amount.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.amount, fieldNumber: 2)
    }
    if !self.swapID.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapID, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DepositHashTimerLockMsg, rhs: DepositHashTimerLockMsg) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.amount != rhs.amount {return false}
    if lhs.swapID != rhs.swapID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ClaimHashTimerLockMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ClaimHashTimerLockMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .standard(proto: "swap_id"),
    3: .standard(proto: "random_number"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularBytesField(value: &self.swapID)
      case 3: try decoder.decodeSingularBytesField(value: &self.randomNumber)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.swapID.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapID, fieldNumber: 2)
    }
    if !self.randomNumber.isEmpty {
      try visitor.visitSingularBytesField(value: self.randomNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ClaimHashTimerLockMsg, rhs: ClaimHashTimerLockMsg) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.swapID != rhs.swapID {return false}
    if lhs.randomNumber != rhs.randomNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RefundHashTimerLockMsg: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RefundHashTimerLockMsg"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "from"),
    2: .standard(proto: "swap_id"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.from)
      case 2: try decoder.decodeSingularBytesField(value: &self.swapID)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.from.isEmpty {
      try visitor.visitSingularBytesField(value: self.from, fieldNumber: 1)
    }
    if !self.swapID.isEmpty {
      try visitor.visitSingularBytesField(value: self.swapID, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RefundHashTimerLockMsg, rhs: RefundHashTimerLockMsg) -> Bool {
    if lhs.from != rhs.from {return false}
    if lhs.swapID != rhs.swapID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
